<!DOCTYPE html>
<!-- saved from url=(0051)http://gityuan.com/2016/09/04/binder-start-service/ -->
<html lang="en" class="gr__gityuan_com"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><style class="anchorjs"></style><style class="darkreader darkreader--sync" media="screen"></style><style class="darkreader darkreader--fallback" media="screen"></style><style class="darkreader darkreader--text" media="screen"></style><style class="darkreader darkreader--invert" media="screen"></style><style class="darkreader darkreader--inline" media="screen">[data-darkreader-inline-bgcolor] {
  background-color: var(--darkreader-inline-bgcolor) !important;
}
[data-darkreader-inline-bgimage] {
  background-image: var(--darkreader-inline-bgimage) !important;
}
[data-darkreader-inline-border] {
  border-color: var(--darkreader-inline-border) !important;
}
[data-darkreader-inline-border-bottom] {
  border-bottom-color: var(--darkreader-inline-border-bottom) !important;
}
[data-darkreader-inline-border-left] {
  border-left-color: var(--darkreader-inline-border-left) !important;
}
[data-darkreader-inline-border-right] {
  border-right-color: var(--darkreader-inline-border-right) !important;
}
[data-darkreader-inline-border-top] {
  border-top-color: var(--darkreader-inline-border-top) !important;
}
[data-darkreader-inline-boxshadow] {
  box-shadow: var(--darkreader-inline-boxshadow) !important;
}
[data-darkreader-inline-color] {
  color: var(--darkreader-inline-color) !important;
}
[data-darkreader-inline-fill] {
  fill: var(--darkreader-inline-fill) !important;
}
[data-darkreader-inline-stroke] {
  stroke: var(--darkreader-inline-stroke) !important;
}
[data-darkreader-inline-outline] {
  outline-color: var(--darkreader-inline-outline) !important;
}</style><style class="darkreader darkreader--user-agent" media="screen">html {
    background-color: #0b0b0c !important;
}
html, body, input, textarea, select, button {
    background-color: #0b0b0c;
}
html, body, input, textarea, select, button {
    border-color: #4c4b49;
    color: #e0dcd5;
}
a {
    color: #5e7ea2;
}
table {
    border-color: #41403e;
}
::placeholder {
    color: #ada9a2;
}
::selection {
    background-color: #29486f;
    color: #f8f5ee;
}
::-moz-selection {
    background-color: #29486f;
    color: #f8f5ee;
}
input:-webkit-autofill,
textarea:-webkit-autofill,
select:-webkit-autofill {
    background-color: #484927 !important;
    color: #e0dcd5 !important;
}
::-webkit-scrollbar {
    background-color: #0f0f11;
    color: #b9b5ae;
}
::-webkit-scrollbar-thumb {
    background-color: #1c1d20;
}
::-webkit-scrollbar-thumb:hover {
    background-color: #232528;
}
::-webkit-scrollbar-thumb:active {
    background-color: #2c3035;
}
::-webkit-scrollbar-corner {
    background-color: #0b0b0c;
}
* {
    scrollbar-color: #1c1d20 #0f0f11;
}</style>
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="Cache-Control" content="max-age=36000">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="gityuan">
    <meta name="keyword" content="Android,Gityuan,Android博客,Android源码,袁辉辉">
    <meta name="description" content="Android架构,Gityuan,Android博客,Android源码,袁辉辉">
    <meta name="baidu-site-verification" content="LToTaY8RGk">
    <link rel="shortcut icon" href="http://gityuan.com/images/favicon.ico">
    <title>彻底理解Android Binder通信架构 - Gityuan博客 | 袁辉辉的Android博客</title>

    <link rel="canonical" href="http://gityuan.com/2016/09/04/binder-start-service/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/bootstrap.min.css"><style class="darkreader darkreader--sync" media="screen"></style>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/hux-blog.min.css"><style class="darkreader darkreader--sync" media="screen"></style>

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/syntax.css"><style class="darkreader darkreader--sync" media="screen"></style>

    <!-- Custom Fonts -->
    <!-- change font-awesome CDN to qiniu -->
    <link href="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/font-awesome.min.css" rel="stylesheet" type="text/css"><style class="darkreader darkreader--cors" media="screen">.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=1);-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=2);-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=3);-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);-webkit-transform:scale(-1, 1);-ms-transform:scale(-1, 1);transform:scale(-1, 1)}.fa-flip-vertical{filter:progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);-webkit-transform:scale(1, -1);-ms-transform:scale(1, -1);transform:scale(1, -1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\f000"}.fa-music:before{content:"\f001"}.fa-search:before{content:"\f002"}.fa-envelope-o:before{content:"\f003"}.fa-heart:before{content:"\f004"}.fa-star:before{content:"\f005"}.fa-star-o:before{content:"\f006"}.fa-user:before{content:"\f007"}.fa-film:before{content:"\f008"}.fa-th-large:before{content:"\f009"}.fa-th:before{content:"\f00a"}.fa-th-list:before{content:"\f00b"}.fa-check:before{content:"\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\f00d"}.fa-search-plus:before{content:"\f00e"}.fa-search-minus:before{content:"\f010"}.fa-power-off:before{content:"\f011"}.fa-signal:before{content:"\f012"}.fa-gear:before,.fa-cog:before{content:"\f013"}.fa-trash-o:before{content:"\f014"}.fa-home:before{content:"\f015"}.fa-file-o:before{content:"\f016"}.fa-clock-o:before{content:"\f017"}.fa-road:before{content:"\f018"}.fa-download:before{content:"\f019"}.fa-arrow-circle-o-down:before{content:"\f01a"}.fa-arrow-circle-o-up:before{content:"\f01b"}.fa-inbox:before{content:"\f01c"}.fa-play-circle-o:before{content:"\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\f01e"}.fa-refresh:before{content:"\f021"}.fa-list-alt:before{content:"\f022"}.fa-lock:before{content:"\f023"}.fa-flag:before{content:"\f024"}.fa-headphones:before{content:"\f025"}.fa-volume-off:before{content:"\f026"}.fa-volume-down:before{content:"\f027"}.fa-volume-up:before{content:"\f028"}.fa-qrcode:before{content:"\f029"}.fa-barcode:before{content:"\f02a"}.fa-tag:before{content:"\f02b"}.fa-tags:before{content:"\f02c"}.fa-book:before{content:"\f02d"}.fa-bookmark:before{content:"\f02e"}.fa-print:before{content:"\f02f"}.fa-camera:before{content:"\f030"}.fa-font:before{content:"\f031"}.fa-bold:before{content:"\f032"}.fa-italic:before{content:"\f033"}.fa-text-height:before{content:"\f034"}.fa-text-width:before{content:"\f035"}.fa-align-left:before{content:"\f036"}.fa-align-center:before{content:"\f037"}.fa-align-right:before{content:"\f038"}.fa-align-justify:before{content:"\f039"}.fa-list:before{content:"\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\f03b"}.fa-indent:before{content:"\f03c"}.fa-video-camera:before{content:"\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\f03e"}.fa-pencil:before{content:"\f040"}.fa-map-marker:before{content:"\f041"}.fa-adjust:before{content:"\f042"}.fa-tint:before{content:"\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\f044"}.fa-share-square-o:before{content:"\f045"}.fa-check-square-o:before{content:"\f046"}.fa-arrows:before{content:"\f047"}.fa-step-backward:before{content:"\f048"}.fa-fast-backward:before{content:"\f049"}.fa-backward:before{content:"\f04a"}.fa-play:before{content:"\f04b"}.fa-pause:before{content:"\f04c"}.fa-stop:before{content:"\f04d"}.fa-forward:before{content:"\f04e"}.fa-fast-forward:before{content:"\f050"}.fa-step-forward:before{content:"\f051"}.fa-eject:before{content:"\f052"}.fa-chevron-left:before{content:"\f053"}.fa-chevron-right:before{content:"\f054"}.fa-plus-circle:before{content:"\f055"}.fa-minus-circle:before{content:"\f056"}.fa-times-circle:before{content:"\f057"}.fa-check-circle:before{content:"\f058"}.fa-question-circle:before{content:"\f059"}.fa-info-circle:before{content:"\f05a"}.fa-crosshairs:before{content:"\f05b"}.fa-times-circle-o:before{content:"\f05c"}.fa-check-circle-o:before{content:"\f05d"}.fa-ban:before{content:"\f05e"}.fa-arrow-left:before{content:"\f060"}.fa-arrow-right:before{content:"\f061"}.fa-arrow-up:before{content:"\f062"}.fa-arrow-down:before{content:"\f063"}.fa-mail-forward:before,.fa-share:before{content:"\f064"}.fa-expand:before{content:"\f065"}.fa-compress:before{content:"\f066"}.fa-plus:before{content:"\f067"}.fa-minus:before{content:"\f068"}.fa-asterisk:before{content:"\f069"}.fa-exclamation-circle:before{content:"\f06a"}.fa-gift:before{content:"\f06b"}.fa-leaf:before{content:"\f06c"}.fa-fire:before{content:"\f06d"}.fa-eye:before{content:"\f06e"}.fa-eye-slash:before{content:"\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\f071"}.fa-plane:before{content:"\f072"}.fa-calendar:before{content:"\f073"}.fa-random:before{content:"\f074"}.fa-comment:before{content:"\f075"}.fa-magnet:before{content:"\f076"}.fa-chevron-up:before{content:"\f077"}.fa-chevron-down:before{content:"\f078"}.fa-retweet:before{content:"\f079"}.fa-shopping-cart:before{content:"\f07a"}.fa-folder:before{content:"\f07b"}.fa-folder-open:before{content:"\f07c"}.fa-arrows-v:before{content:"\f07d"}.fa-arrows-h:before{content:"\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\f080"}.fa-twitter-square:before{content:"\f081"}.fa-facebook-square:before{content:"\f082"}.fa-camera-retro:before{content:"\f083"}.fa-key:before{content:"\f084"}.fa-gears:before,.fa-cogs:before{content:"\f085"}.fa-comments:before{content:"\f086"}.fa-thumbs-o-up:before{content:"\f087"}.fa-thumbs-o-down:before{content:"\f088"}.fa-star-half:before{content:"\f089"}.fa-heart-o:before{content:"\f08a"}.fa-sign-out:before{content:"\f08b"}.fa-linkedin-square:before{content:"\f08c"}.fa-thumb-tack:before{content:"\f08d"}.fa-external-link:before{content:"\f08e"}.fa-sign-in:before{content:"\f090"}.fa-trophy:before{content:"\f091"}.fa-github-square:before{content:"\f092"}.fa-upload:before{content:"\f093"}.fa-lemon-o:before{content:"\f094"}.fa-phone:before{content:"\f095"}.fa-square-o:before{content:"\f096"}.fa-bookmark-o:before{content:"\f097"}.fa-phone-square:before{content:"\f098"}.fa-twitter:before{content:"\f099"}.fa-facebook:before{content:"\f09a"}.fa-github:before{content:"\f09b"}.fa-unlock:before{content:"\f09c"}.fa-credit-card:before{content:"\f09d"}.fa-rss:before{content:"\f09e"}.fa-hdd-o:before{content:"\f0a0"}.fa-bullhorn:before{content:"\f0a1"}.fa-bell:before{content:"\f0f3"}.fa-certificate:before{content:"\f0a3"}.fa-hand-o-right:before{content:"\f0a4"}.fa-hand-o-left:before{content:"\f0a5"}.fa-hand-o-up:before{content:"\f0a6"}.fa-hand-o-down:before{content:"\f0a7"}.fa-arrow-circle-left:before{content:"\f0a8"}.fa-arrow-circle-right:before{content:"\f0a9"}.fa-arrow-circle-up:before{content:"\f0aa"}.fa-arrow-circle-down:before{content:"\f0ab"}.fa-globe:before{content:"\f0ac"}.fa-wrench:before{content:"\f0ad"}.fa-tasks:before{content:"\f0ae"}.fa-filter:before{content:"\f0b0"}.fa-briefcase:before{content:"\f0b1"}.fa-arrows-alt:before{content:"\f0b2"}.fa-group:before,.fa-users:before{content:"\f0c0"}.fa-chain:before,.fa-link:before{content:"\f0c1"}.fa-cloud:before{content:"\f0c2"}.fa-flask:before{content:"\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\f0c5"}.fa-paperclip:before{content:"\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\f0c7"}.fa-square:before{content:"\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\f0c9"}.fa-list-ul:before{content:"\f0ca"}.fa-list-ol:before{content:"\f0cb"}.fa-strikethrough:before{content:"\f0cc"}.fa-underline:before{content:"\f0cd"}.fa-table:before{content:"\f0ce"}.fa-magic:before{content:"\f0d0"}.fa-truck:before{content:"\f0d1"}.fa-pinterest:before{content:"\f0d2"}.fa-pinterest-square:before{content:"\f0d3"}.fa-google-plus-square:before{content:"\f0d4"}.fa-google-plus:before{content:"\f0d5"}.fa-money:before{content:"\f0d6"}.fa-caret-down:before{content:"\f0d7"}.fa-caret-up:before{content:"\f0d8"}.fa-caret-left:before{content:"\f0d9"}.fa-caret-right:before{content:"\f0da"}.fa-columns:before{content:"\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\f0de"}.fa-envelope:before{content:"\f0e0"}.fa-linkedin:before{content:"\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\f0e4"}.fa-comment-o:before{content:"\f0e5"}.fa-comments-o:before{content:"\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\f0e7"}.fa-sitemap:before{content:"\f0e8"}.fa-umbrella:before{content:"\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\f0ea"}.fa-lightbulb-o:before{content:"\f0eb"}.fa-exchange:before{content:"\f0ec"}.fa-cloud-download:before{content:"\f0ed"}.fa-cloud-upload:before{content:"\f0ee"}.fa-user-md:before{content:"\f0f0"}.fa-stethoscope:before{content:"\f0f1"}.fa-suitcase:before{content:"\f0f2"}.fa-bell-o:before{content:"\f0a2"}.fa-coffee:before{content:"\f0f4"}.fa-cutlery:before{content:"\f0f5"}.fa-file-text-o:before{content:"\f0f6"}.fa-building-o:before{content:"\f0f7"}.fa-hospital-o:before{content:"\f0f8"}.fa-ambulance:before{content:"\f0f9"}.fa-medkit:before{content:"\f0fa"}.fa-fighter-jet:before{content:"\f0fb"}.fa-beer:before{content:"\f0fc"}.fa-h-square:before{content:"\f0fd"}.fa-plus-square:before{content:"\f0fe"}.fa-angle-double-left:before{content:"\f100"}.fa-angle-double-right:before{content:"\f101"}.fa-angle-double-up:before{content:"\f102"}.fa-angle-double-down:before{content:"\f103"}.fa-angle-left:before{content:"\f104"}.fa-angle-right:before{content:"\f105"}.fa-angle-up:before{content:"\f106"}.fa-angle-down:before{content:"\f107"}.fa-desktop:before{content:"\f108"}.fa-laptop:before{content:"\f109"}.fa-tablet:before{content:"\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\f10b"}.fa-circle-o:before{content:"\f10c"}.fa-quote-left:before{content:"\f10d"}.fa-quote-right:before{content:"\f10e"}.fa-spinner:before{content:"\f110"}.fa-circle:before{content:"\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\f112"}.fa-github-alt:before{content:"\f113"}.fa-folder-o:before{content:"\f114"}.fa-folder-open-o:before{content:"\f115"}.fa-smile-o:before{content:"\f118"}.fa-frown-o:before{content:"\f119"}.fa-meh-o:before{content:"\f11a"}.fa-gamepad:before{content:"\f11b"}.fa-keyboard-o:before{content:"\f11c"}.fa-flag-o:before{content:"\f11d"}.fa-flag-checkered:before{content:"\f11e"}.fa-terminal:before{content:"\f120"}.fa-code:before{content:"\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\f123"}.fa-location-arrow:before{content:"\f124"}.fa-crop:before{content:"\f125"}.fa-code-fork:before{content:"\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\f127"}.fa-question:before{content:"\f128"}.fa-info:before{content:"\f129"}.fa-exclamation:before{content:"\f12a"}.fa-superscript:before{content:"\f12b"}.fa-subscript:before{content:"\f12c"}.fa-eraser:before{content:"\f12d"}.fa-puzzle-piece:before{content:"\f12e"}.fa-microphone:before{content:"\f130"}.fa-microphone-slash:before{content:"\f131"}.fa-shield:before{content:"\f132"}.fa-calendar-o:before{content:"\f133"}.fa-fire-extinguisher:before{content:"\f134"}.fa-rocket:before{content:"\f135"}.fa-maxcdn:before{content:"\f136"}.fa-chevron-circle-left:before{content:"\f137"}.fa-chevron-circle-right:before{content:"\f138"}.fa-chevron-circle-up:before{content:"\f139"}.fa-chevron-circle-down:before{content:"\f13a"}.fa-html5:before{content:"\f13b"}.fa-css3:before{content:"\f13c"}.fa-anchor:before{content:"\f13d"}.fa-unlock-alt:before{content:"\f13e"}.fa-bullseye:before{content:"\f140"}.fa-ellipsis-h:before{content:"\f141"}.fa-ellipsis-v:before{content:"\f142"}.fa-rss-square:before{content:"\f143"}.fa-play-circle:before{content:"\f144"}.fa-ticket:before{content:"\f145"}.fa-minus-square:before{content:"\f146"}.fa-minus-square-o:before{content:"\f147"}.fa-level-up:before{content:"\f148"}.fa-level-down:before{content:"\f149"}.fa-check-square:before{content:"\f14a"}.fa-pencil-square:before{content:"\f14b"}.fa-external-link-square:before{content:"\f14c"}.fa-share-square:before{content:"\f14d"}.fa-compass:before{content:"\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\f152"}.fa-euro:before,.fa-eur:before{content:"\f153"}.fa-gbp:before{content:"\f154"}.fa-dollar:before,.fa-usd:before{content:"\f155"}.fa-rupee:before,.fa-inr:before{content:"\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\f158"}.fa-won:before,.fa-krw:before{content:"\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\f15a"}.fa-file:before{content:"\f15b"}.fa-file-text:before{content:"\f15c"}.fa-sort-alpha-asc:before{content:"\f15d"}.fa-sort-alpha-desc:before{content:"\f15e"}.fa-sort-amount-asc:before{content:"\f160"}.fa-sort-amount-desc:before{content:"\f161"}.fa-sort-numeric-asc:before{content:"\f162"}.fa-sort-numeric-desc:before{content:"\f163"}.fa-thumbs-up:before{content:"\f164"}.fa-thumbs-down:before{content:"\f165"}.fa-youtube-square:before{content:"\f166"}.fa-youtube:before{content:"\f167"}.fa-xing:before{content:"\f168"}.fa-xing-square:before{content:"\f169"}.fa-youtube-play:before{content:"\f16a"}.fa-dropbox:before{content:"\f16b"}.fa-stack-overflow:before{content:"\f16c"}.fa-instagram:before{content:"\f16d"}.fa-flickr:before{content:"\f16e"}.fa-adn:before{content:"\f170"}.fa-bitbucket:before{content:"\f171"}.fa-bitbucket-square:before{content:"\f172"}.fa-tumblr:before{content:"\f173"}.fa-tumblr-square:before{content:"\f174"}.fa-long-arrow-down:before{content:"\f175"}.fa-long-arrow-up:before{content:"\f176"}.fa-long-arrow-left:before{content:"\f177"}.fa-long-arrow-right:before{content:"\f178"}.fa-apple:before{content:"\f179"}.fa-windows:before{content:"\f17a"}.fa-android:before{content:"\f17b"}.fa-linux:before{content:"\f17c"}.fa-dribbble:before{content:"\f17d"}.fa-skype:before{content:"\f17e"}.fa-foursquare:before{content:"\f180"}.fa-trello:before{content:"\f181"}.fa-female:before{content:"\f182"}.fa-male:before{content:"\f183"}.fa-gittip:before{content:"\f184"}.fa-sun-o:before{content:"\f185"}.fa-moon-o:before{content:"\f186"}.fa-archive:before{content:"\f187"}.fa-bug:before{content:"\f188"}.fa-vk:before{content:"\f189"}.fa-weibo:before{content:"\f18a"}.fa-renren:before{content:"\f18b"}.fa-pagelines:before{content:"\f18c"}.fa-stack-exchange:before{content:"\f18d"}.fa-arrow-circle-o-right:before{content:"\f18e"}.fa-arrow-circle-o-left:before{content:"\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\f191"}.fa-dot-circle-o:before{content:"\f192"}.fa-wheelchair:before{content:"\f193"}.fa-vimeo-square:before{content:"\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\f195"}.fa-plus-square-o:before{content:"\f196"}.fa-space-shuttle:before{content:"\f197"}.fa-slack:before{content:"\f198"}.fa-envelope-square:before{content:"\f199"}.fa-wordpress:before{content:"\f19a"}.fa-openid:before{content:"\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\f19d"}.fa-yahoo:before{content:"\f19e"}.fa-google:before{content:"\f1a0"}.fa-reddit:before{content:"\f1a1"}.fa-reddit-square:before{content:"\f1a2"}.fa-stumbleupon-circle:before{content:"\f1a3"}.fa-stumbleupon:before{content:"\f1a4"}.fa-delicious:before{content:"\f1a5"}.fa-digg:before{content:"\f1a6"}.fa-pied-piper:before{content:"\f1a7"}.fa-pied-piper-alt:before{content:"\f1a8"}.fa-drupal:before{content:"\f1a9"}.fa-joomla:before{content:"\f1aa"}.fa-language:before{content:"\f1ab"}.fa-fax:before{content:"\f1ac"}.fa-building:before{content:"\f1ad"}.fa-child:before{content:"\f1ae"}.fa-paw:before{content:"\f1b0"}.fa-spoon:before{content:"\f1b1"}.fa-cube:before{content:"\f1b2"}.fa-cubes:before{content:"\f1b3"}.fa-behance:before{content:"\f1b4"}.fa-behance-square:before{content:"\f1b5"}.fa-steam:before{content:"\f1b6"}.fa-steam-square:before{content:"\f1b7"}.fa-recycle:before{content:"\f1b8"}.fa-automobile:before,.fa-car:before{content:"\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\f1ba"}.fa-tree:before{content:"\f1bb"}.fa-spotify:before{content:"\f1bc"}.fa-deviantart:before{content:"\f1bd"}.fa-soundcloud:before{content:"\f1be"}.fa-database:before{content:"\f1c0"}.fa-file-pdf-o:before{content:"\f1c1"}.fa-file-word-o:before{content:"\f1c2"}.fa-file-excel-o:before{content:"\f1c3"}.fa-file-powerpoint-o:before{content:"\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\f1c8"}.fa-file-code-o:before{content:"\f1c9"}.fa-vine:before{content:"\f1ca"}.fa-codepen:before{content:"\f1cb"}.fa-jsfiddle:before{content:"\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\f1cd"}.fa-circle-o-notch:before{content:"\f1ce"}.fa-ra:before,.fa-rebel:before{content:"\f1d0"}.fa-ge:before,.fa-empire:before{content:"\f1d1"}.fa-git-square:before{content:"\f1d2"}.fa-git:before{content:"\f1d3"}.fa-hacker-news:before{content:"\f1d4"}.fa-tencent-weibo:before{content:"\f1d5"}.fa-qq:before{content:"\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\f1d9"}.fa-history:before{content:"\f1da"}.fa-circle-thin:before{content:"\f1db"}.fa-header:before{content:"\f1dc"}.fa-paragraph:before{content:"\f1dd"}.fa-sliders:before{content:"\f1de"}.fa-share-alt:before{content:"\f1e0"}.fa-share-alt-square:before{content:"\f1e1"}.fa-bomb:before{content:"\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\f1e3"}.fa-tty:before{content:"\f1e4"}.fa-binoculars:before{content:"\f1e5"}.fa-plug:before{content:"\f1e6"}.fa-slideshare:before{content:"\f1e7"}.fa-twitch:before{content:"\f1e8"}.fa-yelp:before{content:"\f1e9"}.fa-newspaper-o:before{content:"\f1ea"}.fa-wifi:before{content:"\f1eb"}.fa-calculator:before{content:"\f1ec"}.fa-paypal:before{content:"\f1ed"}.fa-google-wallet:before{content:"\f1ee"}.fa-cc-visa:before{content:"\f1f0"}.fa-cc-mastercard:before{content:"\f1f1"}.fa-cc-discover:before{content:"\f1f2"}.fa-cc-amex:before{content:"\f1f3"}.fa-cc-paypal:before{content:"\f1f4"}.fa-cc-stripe:before{content:"\f1f5"}.fa-bell-slash:before{content:"\f1f6"}.fa-bell-slash-o:before{content:"\f1f7"}.fa-trash:before{content:"\f1f8"}.fa-copyright:before{content:"\f1f9"}.fa-at:before{content:"\f1fa"}.fa-eyedropper:before{content:"\f1fb"}.fa-paint-brush:before{content:"\f1fc"}.fa-birthday-cake:before{content:"\f1fd"}.fa-area-chart:before{content:"\f1fe"}.fa-pie-chart:before{content:"\f200"}.fa-line-chart:before{content:"\f201"}.fa-lastfm:before{content:"\f202"}.fa-lastfm-square:before{content:"\f203"}.fa-toggle-off:before{content:"\f204"}.fa-toggle-on:before{content:"\f205"}.fa-bicycle:before{content:"\f206"}.fa-bus:before{content:"\f207"}.fa-ioxhost:before{content:"\f208"}.fa-angellist:before{content:"\f209"}.fa-cc:before{content:"\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\f20b"}.fa-meanpath:before{content:"\f20c"}</style><style class="darkreader darkreader--sync" media="screen"></style>
    
    <!-- add highlight -->
    <link rel="stylesheet" href="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/androidstudio.css"><style class="darkreader darkreader--sync" media="screen"></style>
		<script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/jquery.nav.js.download"></script><script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/fastclick.min.js.download"></script><script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/hm.js.download"></script><script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/anchor.min.js.download"></script><script type="text/javascript" src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/highlight.pack.js.download"></script><style class="darkreader darkreader--override" media="screen">.jfk-bubble {
    background-color: #000000 !important;
}
.vimvixen-hint {
    background-color: #574720 !important;
    border-color: #b3a266 !important;
    color: #e4ddcc !important;
}</style>
		<script>hljs.initHighlightingOnLoad();</script>
		
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="" data-gr-c-s-loaded="true">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top is-fixed">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="http://gityuan.com/">Gityuan</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar" class=" ">
            <div class="navbar-collapse" style="height: 0px;">
                <ul class="nav navbar-nav navbar-right">
                    <li><a href="http://gityuan.com/">首页</a></li>
                    <li><a href="http://gityuan.com/archive">目录</a></li>
                    <!--<li><a href="/tags">标签</a></li>-->
                    <li><a href="http://gityuan.com/talk">留言区</a></li>
                    <li><a href="http://gityuan.com/about">关于</a></li>
                    <li><a href="http://gityuan.com/friends">友链</a></li>
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- _posts目录文章布局-->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/');
    }

    
</style><style class="darkreader darkreader--sync" media="screen"></style>
<header class="intro-header">
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                        <a target="_blank" class="tag" href="http://gityuan.com/tags/#android" title="android">android</a>
                        
                        <a target="_blank" class="tag" href="http://gityuan.com/tags/#binder" title="binder">binder</a>
                        
                        <a target="_blank" class="tag" href="http://gityuan.com/tags/#%E7%BB%84%E4%BB%B6%E7%B3%BB%E5%88%97" title="组件系列">组件系列</a>
                        
                    </div>
                    <h1 id="android-binder">彻底理解Android Binder通信架构</h1>
                    
                    
                    <h2 class="subheading" id=""></h2>
                    
                    <span class="meta">Posted by Gityuan on September 4, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

								<blockquote>
  <p>基于Android 6.0的源码剖析， 本文深度剖析Binder IPC过程, 这绝对是一篇匠心巨作，从Java framework到Native，再到Linux Kernel，带你全程看Binder通信过程.</p>
</blockquote>

<h2 id="一-引言">一. 引言<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%B8%80-%E5%BC%95%E8%A8%80" aria-label="Anchor link for: 一 引言" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<h4 id="11-binder架构的思考">1.1 Binder架构的思考<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#11-binder%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83" aria-label="Anchor link for: 11 binder架构的思考" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>Android内核是基于Linux系统, 而Linux现存多种进程间IPC方式:管道, 消息队列, 共享内存, 套接字, 信号量, 信号. 为什么Android非要用Binder来进行进程间通信呢.
从我个人的理解角度, 曾尝试着在知乎回答同样一个问题 <a href="https://www.zhihu.com/question/39440766/answer/89210950">为什么Android要采用Binder作为IPC机制？</a>.
这是Gityuan第一次认认真真地在知乎上回答问题, 收到很多网友的点赞与回复, 让我很受鼓舞, 也决心分享更多优先地文章回报读者和粉丝, 为Android圈贡献自己的微薄之力。</p>

<p>在说到Binder架构之前, 先简单说说大家熟悉的TCP/IP的五层通信体系结构:</p>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/tcp_ip_arch.jpg" alt="tcp_ip_arch"></p>

<ul>
  <li>应用层: 直接为用户提供服务;</li>
  <li>传输层: 传输的是报文(TCP数据)或者用户数据报(UDP数据)</li>
  <li>网络层: 传输的是包(Packet), 例如路由器</li>
  <li>数据链路层: 传输的是帧(Frame), 例如以太网交换机</li>
  <li>物理层: 相邻节点间传输bit, 例如集线器,双绞线等</li>
</ul>

<p>这是经典的五层TPC/IP协议体系, 这样分层设计的思想, 让每一个子问题都设计成一个独立的协议, 这协议的设计/分析/实现/测试都变得更加简单:</p>

<ul>
  <li>层与层具有独立性, 例如应用层可以使用传输层提供的功能而无需知晓其实现原理;</li>
  <li>设计灵活, 层与层之间都定义好接口, 即便层内方法发生变化,只有接口不变, 对这个系统便毫无影响;</li>
  <li>结构的解耦合, 让每一层可以用更适合的技术方案, 更合适的语言;</li>
  <li>方便维护, 可分层调试和定位问题;</li>
</ul>

<p>Binder架构也是采用分层架构设计, 每一层都有其不同的功能:</p>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/binder_ipc_arch.jpg" alt="binder_ipc_arch"></p>

<ul>
  <li><strong>Java应用层:</strong> 对于上层应用通过调用AMP.startService, 完全可以不用关心底层,经过层层调用,最终必然会调用到AMS.startService.</li>
  <li><strong>Java IPC层:</strong> Binder通信是采用C/S架构, Android系统的基础架构便已设计好Binder在Java framework层的Binder客户类BinderProxy和服务类Binder;</li>
  <li><strong>Native IPC层:</strong> 对于Native层,如果需要直接使用Binder(比如media相关), 则可以直接使用BpBinder和BBinder(当然这里还有JavaBBinder)即可, 对于上一层Java IPC的通信也是基于这个层面.</li>
  <li><strong>Kernel物理层:</strong> 这里是Binder Driver, 前面3层都跑在用户空间,对于用户空间的内存资源是不共享的,每个Android的进程只能运行在自己进程所拥有的虚拟地址空间, 而内核空间却是可共享的. 真正通信的核心环节还是在Binder Driver.</li>
</ul>

<h4 id="12-分析起点">1.2 分析起点<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#12-%E5%88%86%E6%9E%90%E8%B5%B7%E7%82%B9" aria-label="Anchor link for: 12 分析起点" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>前面通过一个<a href="http://gityuan.com/2015/10/31/binder-prepare/">Binder系列-开篇</a>来从源码讲解了Binder的各个层面, 但是Binder牵涉颇为广泛, 几乎是整个Android架构的顶梁柱, 虽说用了十几篇文章来阐述Binder的各个过程.
但依然还是没有将Binder IPC(进程间通信)的过程彻底说透.</p>

<p>Binder系统如此庞大, 那么这里需要寻求一个出发点来穿针引线, 一窥视Binder全貌. 那么本文将从全新的视角,以<a href="http://gityuan.com/2016/03/06/start-service/">startService流程分析</a>为例子来说说Binder所其作用.
首先在发起方进程调用AMP.startService，经过binder驱动，最终调用系统进程AMS.startService,如下图:</p>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/start_server_binder.jpg" alt="start_server_binder"></p>

<p>AMP和AMN都是实现了IActivityManager接口,AMS继承于AMN.  其中AMP作为Binder的客户端,运行在各个app所在进程, AMN(或AMS)运行在系统进程system_server.</p>

<h4 id="13-binder-ipc原理">1.3 Binder IPC原理<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#13-binder-ipc%E5%8E%9F%E7%90%86" aria-label="Anchor link for: 13 binder ipc原理" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。下面说说startService过程所涉及的Binder对象的架构图：</p>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/ams_ipc.jpg" alt="ams_ipc"></p>

<p>可以看出无论是注册服务和获取服务的过程都需要ServiceManager，需要注意的是此处的Service Manager是指Native层的ServiceManager（C++），并非指framework层的ServiceManager(Java)。ServiceManager是整个Binder通信机制的大管家，是Android进程间通信机制Binder的守护进程，Client端和Server端通信时都需要先获取Service Manager接口，才能开始通信服务, 当然查找到目标信息可以缓存起来则不需要每次都向ServiceManager请求。</p>

<p>图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。</p>

<ol>
  <li><strong>注册服务</strong>：首先AMS注册到ServiceManager。该过程：AMS所在进程(system_server)是客户端，ServiceManager是服务端。</li>
  <li><strong>获取服务</strong>：Client进程使用AMS前，须先向ServiceManager中获取AMS的代理类AMP。该过程：AMP所在进程(app process)是客户端，ServiceManager是服务端。</li>
  <li><strong>使用服务</strong>： app进程根据得到的代理类AMP,便可以直接与AMS所在进程交互。该过程：AMP所在进程(app process)是客户端，AMS所在进程(system_server)是服务端。</li>
</ol>

<p>图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder Driver进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层.</p>

<p>这3大过程每一次都是一个完整的Binder IPC过程, 接下来从源码角度, 仅介绍<strong>第3过程使用服务</strong>, 即展开<code class="highlighter-rouge">AMP.startService是如何调用到AMS.startService的过程</code>.</p>

<p><strong>Tips:</strong> 如果你只想了解大致过程,并不打算细扣源码, 那么你可以略过通信过程源码分析, 仅看本文第一段落和最后段落也能对Binder所有理解.</p>

<h2 id="二-通信过程">二. 通信过程<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%BA%8C-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B" aria-label="Anchor link for: 二 通信过程" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<h3 id="21-ampstartservice">2.1 AMP.startService<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#21-ampstartservice" aria-label="Anchor link for: 21 ampstartservice" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; ActivityManagerNative.java  ::ActivityManagerProxy]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(IApplicationThread caller, Intent service,
            String resolvedType, String callingPackage, <span class="hljs-keyword">int</span> userId)</span> <span class="hljs-keyword">throws</span> RemoteException
</span>{
    <span class="hljs-comment">//获取或创建Parcel对象【见小节2.2】</span>
    Parcel data = Parcel.obtain();
    Parcel reply = Parcel.obtain();
    data.writeInterfaceToken(IActivityManager.descriptor);
    data.writeStrongBinder(caller != <span class="hljs-keyword">null</span> ? caller.asBinder() : <span class="hljs-keyword">null</span>);
    service.writeToParcel(data, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//写入Parcel数据 【见小节2.3】</span>
    data.writeString(resolvedType);
    data.writeString(callingPackage);
    data.writeInt(userId);

    <span class="hljs-comment">//通过Binder传递数据【见小节2.5】</span>
    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class="hljs-number">0</span>);
    <span class="hljs-comment">//读取应答消息的异常情况</span>
    reply.readException();
    <span class="hljs-comment">//根据reply数据来创建ComponentName对象</span>
    ComponentName res = ComponentName.readFromParcel(reply);
    <span class="hljs-comment">//【见小节2.2.3】</span>
    data.recycle();
    reply.recycle();
    <span class="hljs-keyword">return</span> res;
}
</code></pre></div></div>

<p>主要功能:</p>

<ul>
  <li>获取或创建两个Parcel对象,data用于发送数据，reply用于接收应答数据.</li>
  <li>将startService相关数据都封装到Parcel对象data, 其中descriptor = “android.app.IActivityManager”;</li>
  <li>通过Binder传递数据,并将应答消息写入reply;</li>
  <li>读取reply应答消息的异常情况和组件对象;</li>
</ul>

<h3 id="22-parcelobtain">2.2 Parcel.obtain<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#22-parcelobtain" aria-label="Anchor link for: 22 parcelobtain" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>[-&gt; Parcel.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Parcel <span class="hljs-title">obtain</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">final</span> Parcel[] pool = sOwnedPool;
    <span class="hljs-keyword">synchronized</span> (pool) {
        Parcel p;
        <span class="hljs-comment">//POOL_SIZE = 6</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;POOL_SIZE; i++) {
            p = pool[i];
            <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>) {
                pool[i] = <span class="hljs-keyword">null</span>;
                <span class="hljs-keyword">return</span> p;
            }
        }
    }
    <span class="hljs-comment">//当缓存池没有现成的Parcel对象，则直接创建[见流程2.2.1]</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Parcel(<span class="hljs-number">0</span>);
}
</code></pre></div></div>

<p><code class="highlighter-rouge">sOwnedPool</code>是一个大小为6，存放着parcel对象的缓存池,这样设计的目标是用于节省每次都创建Parcel对象的开销。obtain()方法的作用：</p>

<ol>
  <li>先尝试从缓存池<code class="highlighter-rouge">sOwnedPool</code>中查询是否存在缓存Parcel对象，当存在则直接返回该对象;</li>
  <li>如果没有可用的Parcel对象，则直接创建Parcel对象。</li>
</ol>

<h4 id="221-new-parcel">2.2.1 new Parcel<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#221-new-parcel" aria-label="Anchor link for: 221 new parcel" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; Parcel.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Parcel</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nativePtr)</span> </span>{
    <span class="hljs-comment">//初始化本地指针</span>
    init(nativePtr);
}

<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">long</span> nativePtr)</span> </span>{
    <span class="hljs-keyword">if</span> (nativePtr != <span class="hljs-number">0</span>) {
        mNativePtr = nativePtr;
        mOwnsNativeParcelObject = <span class="hljs-keyword">false</span>;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// 首次创建,进入该分支[见流程2.2.2]</span>
        mNativePtr = nativeCreate();
        mOwnsNativeParcelObject = <span class="hljs-keyword">true</span>;
    }
}
</code></pre></div></div>

<p>nativeCreate这是native方法,经过JNI进入native层, 调用android_os_Parcel_create()方法.</p>

<h4 id="222--android_os_parcel_create">2.2.2  android_os_Parcel_create<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#222--android_os_parcel_create" aria-label="Anchor link for: 222  android_os_parcel_create" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; android_os_Parcel.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> jlong <span class="hljs-title">android_os_Parcel_create</span><span class="hljs-params">(JNIEnv* env, jclass clazz)</span>
</span>{
    Parcel* parcel = new Parcel();
    return <span class="hljs-keyword">reinterpret_cast</span>&lt;jlong&gt;(parcel);
}
</code></pre></div></div>

<p>创建C++层的Parcel对象, 该对象指针强制转换为long型, 并保存到Java层的<code class="highlighter-rouge">mNativePtr</code>对象. 创建完Parcel对象利用Parcel对象写数据. 接下来以writeString为例.</p>

<h4 id="223-parcelrecycle">2.2.3 Parcel.recycle<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#223-parcelrecycle" aria-label="Anchor link for: 223 parcelrecycle" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//释放native parcel对象</span>
    freeBuffer();
    <span class="hljs-keyword">final</span> Parcel[] pool;
    <span class="hljs-comment">//根据情况来选择加入相应池</span>
    <span class="hljs-keyword">if</span> (mOwnsNativeParcelObject) {
        pool = sOwnedPool;
    } <span class="hljs-keyword">else</span> {
        mNativePtr = <span class="hljs-number">0</span>;
        pool = sHolderPool;
    }
    <span class="hljs-keyword">synchronized</span> (pool) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;POOL_SIZE; i++) {
            <span class="hljs-keyword">if</span> (pool[i] == <span class="hljs-keyword">null</span>) {
                pool[i] = <span class="hljs-keyword">this</span>;
                <span class="hljs-keyword">return</span>;
            }
        }
    }
}
</code></pre></div></div>

<p>将不再使用的Parcel对象放入缓存池，可回收重复利用，当缓存池已满则不再加入缓存池。这里有两个Parcel线程池,<code class="highlighter-rouge">mOwnsNativeParcelObject</code>变量来决定:</p>

<ul>
  <li><code class="highlighter-rouge">mOwnsNativeParcelObject</code>=true,  即调用不带参数obtain()方法获取的对象, 回收时会放入<code class="highlighter-rouge">sOwnedPool</code>对象池;</li>
  <li><code class="highlighter-rouge">mOwnsNativeParcelObject</code>=false, 即调用带nativePtr参数的obtain(long)方法获取的对象, 回收时会放入<code class="highlighter-rouge">sHolderPool</code>对象池;</li>
</ul>

<h3 id="23-writestring">2.3 writeString<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#23-writestring" aria-label="Anchor link for: 23 writestring" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; Parcel.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeString</span><span class="hljs-params">(String val)</span> </span>{
    <span class="hljs-comment">//[见流程2.3.1]</span>
    nativeWriteString(mNativePtr, val);
}
</code></pre></div></div>

<h4 id="231-nativewritestring">2.3.1 nativeWriteString<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#231-nativewritestring" aria-label="Anchor link for: 231 nativewritestring" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; android_os_Parcel.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">android_os_Parcel_writeString</span><span class="hljs-params">(JNIEnv* env, jclass clazz, jlong nativePtr, jstring val)</span>
</span>{
    Parcel* parcel = <span class="hljs-keyword">reinterpret_cast</span>&lt;Parcel*&gt;(nativePtr);
    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">status_t</span> err = NO_MEMORY;
        <span class="hljs-keyword">if</span> (val) {
            <span class="hljs-keyword">const</span> jchar* str = env-&gt;GetStringCritical(val, <span class="hljs-number">0</span>);
            <span class="hljs-keyword">if</span> (str) {
                <span class="hljs-comment">//[见流程2.3.2]</span>
                err = parcel-&gt;writeString16(
                    reinterpret_cast&lt;const <span class="hljs-keyword">char16_t</span>*&gt;(str),
                    env-&gt;GetStringLength(val));
                env-&gt;ReleaseStringCritical(val, str);
            }
        } <span class="hljs-keyword">else</span> {
            err = parcel-&gt;writeString16(NULL, <span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">if</span> (err != NO_ERROR) {
            signalExceptionForError(env, clazz, err);
        }
    }
}
</code></pre></div></div>

<h4 id="232-writestring16">2.3.2 writeString16<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#232-writestring16" aria-label="Anchor link for: 232 writestring16" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; Parcel.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> Parcel::writeString16(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char16_t</span>* str, <span class="hljs-keyword">size_t</span> len)
{
    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">NULL</span>) return writeInt32(<span class="hljs-number">-1</span>);

    <span class="hljs-keyword">status_t</span> err = writeInt32(len);
    <span class="hljs-keyword">if</span> (err == NO_ERROR) {
        len *= <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char16_t</span>);
        <span class="hljs-keyword">uint8_t</span>* data = (<span class="hljs-keyword">uint8_t</span>*)writeInplace(len+sizeof(<span class="hljs-keyword">char16_t</span>));
        <span class="hljs-keyword">if</span> (data) {
            <span class="hljs-comment">//数据拷贝到data所指向的位置</span>
            <span class="hljs-built_in">memcpy</span>(data, str, len);
            *<span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">char16_t</span>*&gt;(data+len) = <span class="hljs-number">0</span>;
            return NO_ERROR;
        }
        err = mError;
    }
    return err;
}
</code></pre></div></div>

<p><strong>Tips:</strong> 除了writeString(),在<code class="highlighter-rouge">Parcel.java</code>中大量的native方法, 都是调用<code class="highlighter-rouge">android_os_Parcel.cpp</code>相对应的方法, 该方法再调用<code class="highlighter-rouge">Parcel.cpp</code>中对应的方法.  <br>
调用流程:    Parcel.java –&gt;  android_os_Parcel.cpp  –&gt; Parcel.cpp.</p>

<pre><code class="language-Java hljs">frameworks/base/core/java/android/os/Parcel.java
frameworks/base/core/jni/android_os_Parcel.cpp
frameworks/<span class="hljs-keyword">native</span>/libs/binder/Parcel.cpp
</code></pre>

<p>简单说,就是</p>

<h3 id="24-mremote究竟为何物">2.4 mRemote究竟为何物<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#24-mremote%E7%A9%B6%E7%AB%9F%E4%B8%BA%E4%BD%95%E7%89%A9" aria-label="Anchor link for: 24 mremote究竟为何物" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>mRemote的出生,要出先说说ActivityManagerProxy对象(简称AMP)创建说起, AMP是通过ActivityManagerNative.getDefault()来获取的.</p>

<h4 id="241-amngetdefault">2.4.1 AMN.getDefault<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#241-amngetdefault" aria-label="Anchor link for: 241 amngetdefault" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; ActivityManagerNative.java]</p>

<pre><code class="language-Java hljs"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title">getDefault</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// [见流程2.4.2]</span>
    <span class="hljs-keyword">return</span> gDefault.get();
}
</code></pre>

<p>gDefault的数据类型为<code class="highlighter-rouge">Singleton&lt;IActivityManager&gt;</code>, 这是一个单例模式, 接下来看看Singleto.get()的过程</p>

<h4 id="242-gdefaultget">2.4.2 gDefault.get<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#242-gdefaultget" aria-label="Anchor link for: 242 gdefaultget" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&lt;<span class="hljs-title">IActivityManager</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> IActivityManager <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) {
            <span class="hljs-keyword">if</span> (mInstance == <span class="hljs-keyword">null</span>) {
                <span class="hljs-comment">//首次调用create()来获取AMP对象[见流程2.4.3]</span>
                mInstance = create();
            }
            <span class="hljs-keyword">return</span> mInstance;
        }
    }
}
</code></pre></div></div>

<p>首次调用时需要创建,创建完之后保持到mInstance对象,之后可直接使用.</p>

<h4 id="243-gdefaultcreate">2.4.3 gDefault.create<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#243-gdefaultcreate" aria-label="Anchor link for: 243 gdefaultcreate" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton&lt;IActivityManager&gt; gDefault = <span class="hljs-keyword">new</span> Singleton&lt;IActivityManager&gt;() {
    <span class="hljs-function"><span class="hljs-keyword">protected</span> IActivityManager <span class="hljs-title">create</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">//获取名为"activity"的服务</span>
        IBinder b = ServiceManager.getService(<span class="hljs-string">"activity"</span>);
        <span class="hljs-comment">//创建AMP对象[见流程2.4.4]</span>
        IActivityManager am = asInterface(b);
        <span class="hljs-keyword">return</span> am;
    }
};
</code></pre></div></div>

<p>文章<a href="http://gityuan.com/2015/11/21/binder-framework/#section-4">Binder系列7—framework层分析</a>，可知ServiceManager.getService(“activity”)返回的是指向目标服务AMS的代理对象<code class="highlighter-rouge">BinderProxy</code>对象，由该代理对象可以找到目标服务AMS所在进程</p>

<h4 id="244-amnasinterface">2.4.4 AMN.asInterface<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#244-amnasinterface" aria-label="Anchor link for: 244 amnasinterface" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; ActivityManagerNative.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerNative</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IActivityManager</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> IActivityManager <span class="hljs-title">asInterface</span><span class="hljs-params">(IBinder obj)</span> </span>{
        <span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) {
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        }
        <span class="hljs-comment">//此处obj = BinderProxy,  descriptor = "android.app.IActivityManager"; [见流程2.4.5]</span>
        IActivityManager in = (IActivityManager)obj.queryLocalInterface(descriptor);
        <span class="hljs-keyword">if</span> (in != <span class="hljs-keyword">null</span>) { <span class="hljs-comment">//此处为null</span>
            <span class="hljs-keyword">return</span> in;
        }
        <span class="hljs-comment">//[见流程2.4.6]</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ActivityManagerProxy(obj);
    }
    ...
}
</code></pre></div></div>

<p>此时obj为BinderProxy对象, 记录着远程进程system_server中AMS服务的binder线程的handle.</p>

<h4 id="245--querylocalinterface">2.4.5  queryLocalInterface<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#245--querylocalinterface" aria-label="Anchor link for: 245  querylocalinterface" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[Binder.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Binder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span> </span>{
    <span class="hljs-comment">//对于Binder对象的调用,则返回值不为空</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IInterface <span class="hljs-title">queryLocalInterface</span><span class="hljs-params">(String descriptor)</span> </span>{
        <span class="hljs-comment">//mDescriptor的初始化在attachInterface()过程中赋值</span>
        <span class="hljs-keyword">if</span> (mDescriptor.equals(descriptor)) {
            <span class="hljs-keyword">return</span> mOwner;
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}

<span class="hljs-comment">//由上一小节[2.4.4]调用的流程便是此处,返回Null</span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinderProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span> </span>{
    <span class="hljs-comment">//BinderProxy对象的调用, 则返回值为空</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IInterface <span class="hljs-title">queryLocalInterface</span><span class="hljs-params">(String descriptor)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
    }
}
</code></pre></div></div>

<p>对于Binder IPC的过程中, 同一个进程的调用则会是asInterface()方法返回的便是本地的Binder对象;对于不同进程的调用则会是远程代理对象BinderProxy.</p>

<h4 id="246-创建amp">2.4.6 创建AMP<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#246-%E5%88%9B%E5%BB%BAamp" aria-label="Anchor link for: 246 创建amp" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; ActivityManagerNative.java :: AMP]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivityManagerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IActivityManager</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ActivityManagerProxy</span><span class="hljs-params">(IBinder remote)</span>
    </span>{
        mRemote = remote;
    }
}
</code></pre></div></div>

<p>可知<code class="highlighter-rouge">mRemote</code>便是指向AMS服务的<code class="highlighter-rouge">BinderProxy</code>对象。</p>

<h3 id="25-mremotetransact">2.5 mRemote.transact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#25-mremotetransact" aria-label="Anchor link for: 25 mremotetransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; Binder.java ::BinderProxy]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BinderProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IBinder</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">transact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags)</span> <span class="hljs-keyword">throws</span> RemoteException </span>{
        <span class="hljs-comment">//用于检测Parcel大小是否大于800k</span>
        Binder.checkParcel(<span class="hljs-keyword">this</span>, code, data, <span class="hljs-string">"Unreasonably large binder buffer"</span>);
        <span class="hljs-comment">//【见2.6】</span>
        <span class="hljs-keyword">return</span> transactNative(code, data, reply, flags);
    }
}
</code></pre></div></div>

<p>mRemote.transact()方法中的code=START_SERVICE_TRANSACTION, data保存了<code class="highlighter-rouge">descriptor</code>，<code class="highlighter-rouge">caller</code>, <code class="highlighter-rouge">intent</code>, <code class="highlighter-rouge">resolvedType</code>, <code class="highlighter-rouge">callingPackage</code>, <code class="highlighter-rouge">userId</code>这6项信息。</p>

<p>transactNative是native方法，经过jni调用android_os_BinderProxy_transact方法。</p>

<h3 id="26-android_os_binderproxy_transact">2.6 android_os_BinderProxy_transact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#26-android_os_binderproxy_transact" aria-label="Anchor link for: 26 android_os_binderproxy_transact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; android_util_Binder.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php"><span class="hljs-keyword">static</span> jboolean android_os_BinderProxy_transact(JNIEnv* env, jobject obj,
    jint code, jobject dataObj, jobject replyObj, jint flags)
{
    ...
    <span class="hljs-comment">//将java Parcel转为c++ Parcel</span>
    Parcel* data = parcelForJavaObject(env, dataObj);
    Parcel* reply = parcelForJavaObject(env, replyObj);

    <span class="hljs-comment">//gBinderProxyOffsets.mObject中保存的是new BpBinder(handle)对象</span>
    IBinder* target = (IBinder*) env-&gt;GetLongField(obj, gBinderProxyOffsets.mObject);
    ...

    <span class="hljs-comment">//此处便是BpBinder::transact()【见小节2.7】</span>
    status_t err = target-&gt;transact(code, *data, reply, flags);
    ...

    <span class="hljs-comment">//最后根据transact执行具体情况，抛出相应的Exception</span>
    signalExceptionForError(env, obj, err, <span class="hljs-keyword">true</span> , data-&gt;dataSize());
    <span class="hljs-keyword">return</span> JNI_FALSE;
}
</code></pre></div></div>

<p>gBinderProxyOffsets.mObject中保存的是<code class="highlighter-rouge">BpBinder</code>对象, 这是开机时Zygote调用<code class="highlighter-rouge">AndroidRuntime::startReg</code>方法来完成jni方法的注册.</p>

<p>其中register_android_os_Binder()过程就有一个初始并注册BinderProxy的操作,完成gBinderProxyOffsets的赋值过程. 接下来就进入该方法.</p>

<h3 id="27-bpbindertransact">2.7 BpBinder.transact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#27-bpbindertransact" aria-label="Anchor link for: 27 bpbindertransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; BpBinder.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">status_t BpBinder::transact(
    uint32_t code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply, uint32_t flags)
{
    <span class="hljs-keyword">if</span> (mAlive) {
        <span class="hljs-comment">// 【见小节2.8】</span>
        status_t status = IPCThreadState::self()-&gt;transact(
            mHandle, code, data, reply, flags);
        <span class="hljs-keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">return</span> status;
    }
    <span class="hljs-keyword">return</span> DEAD_OBJECT;
}
</code></pre></div></div>

<p>IPCThreadState::self()采用单例模式，保证每个线程只有一个实例对象。</p>

<h3 id="28-ipctransact">2.8 IPC.transact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#28-ipctransact" aria-label="Anchor link for: 28 ipctransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; IPCThreadState.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">status_t IPCThreadState::transact(int32_t handle,
                                  uint32_t code, <span class="hljs-keyword">const</span> Parcel&amp; data,
                                  Parcel* reply, uint32_t flags)
{
    status_t err = data.errorCheck(); <span class="hljs-comment">//数据错误检查</span>
    flags |= TF_ACCEPT_FDS;
    ....
    <span class="hljs-keyword">if</span> (err == NO_ERROR) {
         <span class="hljs-comment">// 传输数据 【见小节2.9】</span>
        err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="hljs-keyword">NULL</span>);
    }

    <span class="hljs-keyword">if</span> (err != NO_ERROR) {
        <span class="hljs-keyword">if</span> (reply) reply-&gt;setError(err);
        <span class="hljs-keyword">return</span> (mLastError = err);
    }

    <span class="hljs-comment">// 默认情况下,都是采用非oneway的方式, 也就是需要等待服务端的返回结果</span>
    <span class="hljs-keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (reply) {
            <span class="hljs-comment">//reply对象不为空 【见小节2.10】</span>
            err = waitForResponse(reply);
        }<span class="hljs-keyword">else</span> {
            Parcel fakeReply;
            err = waitForResponse(&amp;fakeReply);
        }
    } <span class="hljs-keyword">else</span> {
        err = waitForResponse(<span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">NULL</span>);
    }
    <span class="hljs-keyword">return</span> err;
}
</code></pre></div></div>

<p>transact主要过程:</p>

<ul>
  <li>先执行writeTransactionData()已向Parcel数据类型的<code class="highlighter-rouge">mOut</code>写入数据，此时<code class="highlighter-rouge">mIn</code>还没有数据；</li>
  <li>然后执行waitForResponse()方法，循环执行，直到收到应答消息. 调用talkWithDriver()跟驱动交互，收到应答消息，便会写入<code class="highlighter-rouge">mIn</code>, 则根据收到的不同响应吗，执行相应的操作。</li>
</ul>

<p>此处调用waitForResponse根据是否有设置<code class="highlighter-rouge">TF_ONE_WAY</code>的标记:</p>

<ul>
  <li>当已设置oneway时, 则调用waitForResponse(NULL, NULL);</li>
  <li>当未设置oneway时, 则调用waitForResponse(reply) 或 waitForResponse(&amp;fakeReply)</li>
</ul>

<h3 id="29-ipcwritetransactiondata">2.9 IPC.writeTransactionData<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#29-ipcwritetransactiondata" aria-label="Anchor link for: 29 ipcwritetransactiondata" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; IPCThreadState.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> IPCThreadState::writeTransactionData(<span class="hljs-keyword">int32_t</span> cmd, <span class="hljs-keyword">uint32_t</span> binderFlags,
    <span class="hljs-keyword">int32_t</span> handle, <span class="hljs-keyword">uint32_t</span> code, <span class="hljs-keyword">const</span> Parcel&amp; data, <span class="hljs-keyword">status_t</span>* statusBuffer)
{
    binder_transaction_data tr;

    tr.target.ptr = <span class="hljs-number">0</span>;
    tr.target.handle = handle; <span class="hljs-comment">// handle指向AMS</span>
    tr.code = code;            <span class="hljs-comment">// START_SERVICE_TRANSACTION</span>
    tr.flags = binderFlags;    <span class="hljs-comment">// 0</span>
    tr.cookie = <span class="hljs-number">0</span>;
    tr.sender_pid = <span class="hljs-number">0</span>;
    tr.sender_euid = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">status_t</span> err = data.errorCheck();
    <span class="hljs-keyword">if</span> (err == NO_ERROR) {
        <span class="hljs-comment">// data为startService相关信息</span>
        tr.data_size = data.ipcDataSize();   <span class="hljs-comment">// mDataSize</span>
        tr.data.ptr.buffer = data.ipcData(); <span class="hljs-comment">// mData指针</span>
        tr.offsets_size = data.ipcObjectsCount()*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">binder_size_t</span>); <span class="hljs-comment">//mObjectsSize</span>
        tr.data.ptr.offsets = data.ipcObjects(); <span class="hljs-comment">//mObjects指针</span>
    }
    ...
    mOut.writeInt32(cmd);         <span class="hljs-comment">//cmd = BC_TRANSACTION</span>
    mOut.write(&amp;tr, <span class="hljs-keyword">sizeof</span>(tr));  <span class="hljs-comment">//写入binder_transaction_data数据</span>
    return NO_ERROR;
}
</code></pre></div></div>

<p>将数据写入mOut</p>

<h3 id="210-ipcwaitforresponse">2.10 IPC.waitForResponse<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#210-ipcwaitforresponse" aria-label="Anchor link for: 210 ipcwaitforresponse" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="hljs-keyword">status_t</span> *acquireResult)
{
    <span class="hljs-keyword">int32_t</span> cmd;
    <span class="hljs-keyword">int32_t</span> err;

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 【见小节2.11】</span>
        err = mIn.errorCheck();
        <span class="hljs-keyword">if</span> (err &lt; NO_ERROR) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//当存在error则退出循环</span>

         <span class="hljs-comment">//每当跟Driver交互一次，若mIn收到数据则往下执行一次BR命令</span>
        <span class="hljs-keyword">if</span> (mIn.dataAvail() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;

        cmd = mIn.readInt32();

        <span class="hljs-keyword">switch</span> (cmd) {
        <span class="hljs-keyword">case</span> BR_TRANSACTION_COMPLETE:
            <span class="hljs-comment">//只有当不需要reply, 也就是oneway时 才会跳出循环,否则还需要等待.</span>
            <span class="hljs-keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="hljs-keyword">goto</span> finish; <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> BR_DEAD_REPLY:
            err = DEAD_OBJECT;         <span class="hljs-keyword">goto</span> finish;
        <span class="hljs-keyword">case</span> BR_FAILED_REPLY:
            err = FAILED_TRANSACTION;  <span class="hljs-keyword">goto</span> finish;
        <span class="hljs-keyword">case</span> BR_REPLY: ...             <span class="hljs-keyword">goto</span> finish;

        <span class="hljs-keyword">default</span>:
            err = executeCommand(cmd);  <span class="hljs-comment">//【见小节2.12】</span>
            <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;
            <span class="hljs-keyword">break</span>;
        }
    }

finish:
    <span class="hljs-keyword">if</span> (err != NO_ERROR) {
        <span class="hljs-keyword">if</span> (reply) reply-&gt;setError(err); <span class="hljs-comment">//将发送的错误代码返回给最初的调用者</span>
    }
    return err;
}
</code></pre></div></div>

<p>在这个过程中, 收到以下任一BR_命令，处理后便会退出waitForResponse()的状态:</p>

<ul>
  <li>BR_TRANSACTION_COMPLETE: binder驱动收到BC_TRANSACTION事件后的应答消息; 对于oneway transaction,当收到该消息,则完成了本次Binder通信;</li>
  <li>BR_DEAD_REPLY: 回复失败，往往是线程或节点为空. 则结束本次通信Binder;</li>
  <li>BR_FAILED_REPLY:回复失败，往往是transaction出错导致. 则结束本次通信Binder;</li>
  <li>BR_REPLY: Binder驱动向Client端发送回应消息; 对于非oneway transaction时,当收到该消息,则完整地完成本次Binder通信;</li>
</ul>

<p>除了以上命令，其他命令的处理流程【见小节2.12】</p>

<h3 id="211--ipctalkwithdriver">2.11  IPC.talkWithDriver<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#211--ipctalkwithdriver" aria-label="Anchor link for: 211  ipctalkwithdriver" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-comment">//mOut有数据，mIn还没有数据。doReceive默认值为true</span>
<span class="hljs-keyword">status_t</span> IPCThreadState::talkWithDriver(<span class="hljs-keyword">bool</span> doReceive)
{
    binder_write_read bwr;

    <span class="hljs-keyword">const</span> <span class="hljs-keyword">bool</span> needRead = mIn.dataPosition() &gt;= mIn.dataSize();
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">size_t</span> outAvail = (!doReceive || needRead) ? mOut.dataSize() : <span class="hljs-number">0</span>;

    bwr.write_size = outAvail;
    bwr.write_buffer = (<span class="hljs-keyword">uintptr_t</span>)mOut.data();

    <span class="hljs-keyword">if</span> (doReceive &amp;&amp; needRead) {
        <span class="hljs-comment">//接收数据缓冲区信息的填充。当收到驱动的数据，则写入mIn</span>
        bwr.read_size = mIn.dataCapacity();
        bwr.read_buffer = (<span class="hljs-keyword">uintptr_t</span>)mIn.data();
    } <span class="hljs-keyword">else</span> {
        bwr.read_size = <span class="hljs-number">0</span>;
        bwr.read_buffer = <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">// 当同时没有输入和输出数据则直接返回</span>
    <span class="hljs-keyword">if</span> ((bwr.write_size == <span class="hljs-number">0</span>) &amp;&amp; (bwr.read_size == <span class="hljs-number">0</span>)) return NO_ERROR;

    bwr.write_consumed = <span class="hljs-number">0</span>;
    bwr.read_consumed = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">status_t</span> err;
    <span class="hljs-keyword">do</span> {
        <span class="hljs-comment">//ioctl执行binder读写操作，经过syscall，进入Binder驱动。调用Binder_ioctl【小节3.1】</span>
        <span class="hljs-keyword">if</span> (ioctl(mProcess-&gt;mDriverFD, BINDER_WRITE_READ, &amp;bwr) &gt;= <span class="hljs-number">0</span>)
            err = NO_ERROR;
        <span class="hljs-keyword">else</span>
            err = -errno;
        ...
    } <span class="hljs-keyword">while</span> (err == -EINTR);

    <span class="hljs-keyword">if</span> (err &gt;= NO_ERROR) {
        <span class="hljs-keyword">if</span> (bwr.write_consumed &gt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (bwr.write_consumed &lt; mOut.dataSize())
                mOut.remove(<span class="hljs-number">0</span>, bwr.write_consumed);
            <span class="hljs-keyword">else</span>
                mOut.setDataSize(<span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">if</span> (bwr.read_consumed &gt; <span class="hljs-number">0</span>) {
            mIn.setDataSize(bwr.read_consumed);
            mIn.setDataPosition(<span class="hljs-number">0</span>);
        }
        return NO_ERROR;
    }
    return err;
}
</code></pre></div></div>

<p><a href="http://gityuan.com/2015/11/01/binder-driver/#binderwriteread">binder_write_read结构体</a>用来与Binder设备交换数据的结构, 通过ioctl与mDriverFD通信，是真正与Binder驱动进行数据读写交互的过程。</p>

<h3 id="212--ipcexecutecommand">2.12  IPC.executeCommand<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#212--ipcexecutecommand" aria-label="Anchor link for: 212  ipcexecutecommand" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> IPCThreadState::executeCommand(<span class="hljs-keyword">int32_t</span> cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    <span class="hljs-keyword">status_t</span> result = NO_ERROR;

    <span class="hljs-keyword">switch</span> ((<span class="hljs-keyword">uint32_t</span>)cmd) {
    <span class="hljs-keyword">case</span> BR_ERROR: ...
    <span class="hljs-keyword">case</span> BR_OK: ...
    <span class="hljs-keyword">case</span> BR_ACQUIRE: ...
    <span class="hljs-keyword">case</span> BR_RELEASE: ...
    <span class="hljs-keyword">case</span> BR_INCREFS: ...
    <span class="hljs-keyword">case</span> BR_TRANSACTION: ... <span class="hljs-comment">//Binder驱动向Server端发送消息</span>
    <span class="hljs-keyword">case</span> BR_DEAD_BINDER: ...
    <span class="hljs-keyword">case</span> BR_CLEAR_DEATH_NOTIFICATION_DONE: ...
    <span class="hljs-keyword">case</span> BR_NOOP: ...
    <span class="hljs-keyword">case</span> BR_SPAWN_LOOPER: ... <span class="hljs-comment">//创建新binder线程</span>
    <span class="hljs-keyword">default</span>: ...
    }
}
</code></pre></div></div>

<p>再回到【小节2.11】，可知ioctl()方法经过syscall最终调用到Binder_ioctl()方法.</p>

<h2 id="三binder-driver">三、Binder driver<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%B8%89binder-driver" aria-label="Anchor link for: 三binder driver" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<h4 id="31-binder_ioctl">3.1 binder_ioctl<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#31-binder_ioctl" aria-label="Anchor link for: 31 binder_ioctl" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; Binder.c]</p>

<p>由【小节2.11】传递过出来的参数 cmd=<code class="highlighter-rouge">BINDER_WRITE_READ</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> binder_ioctl(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg)
{
    <span class="hljs-keyword">int</span> ret;
    <span class="hljs-keyword">struct</span> binder_proc *proc = filp-&gt;private_data;
    <span class="hljs-keyword">struct</span> binder_thread *thread;

    <span class="hljs-comment">//当binder_stop_on_user_error&gt;=2时，则该线程加入等待队列并进入休眠状态. 该值默认为0</span>
    ret = wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="hljs-number">2</span>);
    ...
    binder_lock(__func__);
    <span class="hljs-comment">//查找或创建binder_thread结构体</span>
    thread = binder_get_thread(proc);
    ...
    <span class="hljs-keyword">switch</span> (cmd) {
        <span class="hljs-keyword">case</span> BINDER_WRITE_READ:
            <span class="hljs-comment">//【见小节3.2】</span>
            ret = binder_ioctl_write_read(filp, cmd, arg, thread);
            <span class="hljs-keyword">break</span>;
        ...
    }
    ret = <span class="hljs-number">0</span>;

err:
    <span class="hljs-keyword">if</span> (thread)
        thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_NEED_RETURN;
    binder_unlock(__func__);
    wait_event_interruptible(binder_user_error_wait, binder_stop_on_user_error &lt; <span class="hljs-number">2</span>);
    <span class="hljs-keyword">return</span> ret;
}
</code></pre></div></div>

<p>首先,根据传递过来的文件句柄指针获取相应的binder_proc结构体, 再从中查找binder_thread,如果当前线程已经加入到proc的线程队列则直接返回，
如果不存在则创建binder_thread，并将当前线程添加到当前的proc.</p>

<ul>
  <li>当返回值为-ENOMEM，则意味着内存不足，往往会出现创建binder_thread对象失败;</li>
  <li>当返回值为-EINVAL，则意味着CMD命令参数无效；</li>
</ul>

<h4 id="32--binder_ioctl_write_read">3.2  binder_ioctl_write_read<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#32--binder_ioctl_write_read" aria-label="Anchor link for: 32  binder_ioctl_write_read" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_ioctl_write_read(<span class="hljs-keyword">struct</span> file *filp,
                <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> cmd, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> arg,
                <span class="hljs-keyword">struct</span> binder_thread *thread)
{
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">struct</span> binder_proc *proc = filp-&gt;private_data;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size = _IOC_SIZE(cmd);
    <span class="hljs-keyword">void</span> __user *ubuf = (<span class="hljs-keyword">void</span> __user *)arg;
    <span class="hljs-keyword">struct</span> binder_write_read bwr;
    <span class="hljs-keyword">if</span> (size != <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binder_write_read)) {
        ret = -EINVAL;
        <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }
    <span class="hljs-comment">//将用户空间bwr结构体拷贝到内核空间</span>
    <span class="hljs-keyword">if</span> (copy_from_user(&amp;bwr, ubuf, <span class="hljs-keyword">sizeof</span>(bwr))) {
        ret = -EFAULT;
        <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }

    <span class="hljs-keyword">if</span> (bwr.write_size &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">//将数据放入目标进程【见小节3.3】</span>
        ret = binder_thread_write(proc, thread,
                      bwr.write_buffer,
                      bwr.write_size,
                      &amp;bwr.write_consumed);
        <span class="hljs-comment">//当执行失败，则直接将内核bwr结构体写回用户空间，并跳出该方法</span>
        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {
            bwr.read_consumed = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">if</span> (copy_to_user_preempt_disabled(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))
                ret = -EFAULT;
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
        }
    }
    <span class="hljs-keyword">if</span> (bwr.read_size &gt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">//读取自己队列的数据 【见小节3.5】</span>
        ret = binder_thread_read(proc, thread, bwr.read_buffer,
             bwr.read_size,
             &amp;bwr.read_consumed,
             filp-&gt;f_flags &amp; O_NONBLOCK);
        <span class="hljs-comment">//当进程的todo队列有数据,则唤醒在该队列等待的进程</span>
        <span class="hljs-keyword">if</span> (!list_empty(&amp;proc-&gt;todo))
            wake_up_interruptible(&amp;proc-&gt;wait);
        <span class="hljs-comment">//当执行失败，则直接将内核bwr结构体写回用户空间，并跳出该方法</span>
        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (copy_to_user_preempt_disabled(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr)))
                ret = -EFAULT;
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
        }
    }

    <span class="hljs-keyword">if</span> (copy_to_user(ubuf, &amp;bwr, <span class="hljs-keyword">sizeof</span>(bwr))) {
        ret = -EFAULT;
        <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }
<span class="hljs-keyword">out</span>:
    <span class="hljs-keyword">return</span> ret;
}   
</code></pre></div></div>

<p>此时arg是一个<code class="highlighter-rouge">binder_write_read</code>结构体，<code class="highlighter-rouge">mOut</code>数据保存在write_buffer，所以write_size&gt;0，但此时read_size=0。首先,将用户空间bwr结构体拷贝到内核空间,然后执行binder_thread_write()操作.</p>

<h4 id="33-binder_thread_write">3.3 binder_thread_write<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#33-binder_thread_write" aria-label="Anchor link for: 33 binder_thread_write" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_thread_write(<span class="hljs-keyword">struct</span> binder_proc *proc,
            <span class="hljs-keyword">struct</span> binder_thread *thread,
            binder_uintptr_t binder_buffer, size_t size,
            binder_size_t *consumed)
{
    uint32_t cmd;
    <span class="hljs-keyword">void</span> __user *buffer = (<span class="hljs-keyword">void</span> __user *)(uintptr_t)binder_buffer;
    <span class="hljs-keyword">void</span> __user *ptr = buffer + *consumed;
    <span class="hljs-keyword">void</span> __user *end = buffer + size;
    <span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
        <span class="hljs-comment">//拷贝用户空间的cmd命令，此时为BC_TRANSACTION</span>
        <span class="hljs-keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT;
        ptr += <span class="hljs-keyword">sizeof</span>(uint32_t);
        <span class="hljs-keyword">switch</span> (cmd) {
        <span class="hljs-keyword">case</span> BC_TRA<span class="hljs-built_in">NSACTION</span>:
        <span class="hljs-keyword">case</span> BC_REPLY: {
            <span class="hljs-keyword">struct</span> binder_transaction_data tr;
            <span class="hljs-comment">//拷贝用户空间的binder_transaction_data</span>
            <span class="hljs-keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="hljs-keyword">sizeof</span>(tr)))   <span class="hljs-keyword">return</span> -EFAULT;
            ptr += <span class="hljs-keyword">sizeof</span>(tr);
            <span class="hljs-comment">// 见小节3.4】</span>
            binder_transaction(proc, thread, &amp;tr, cmd == BC_REPLY);
            <span class="hljs-keyword">break</span>;
        }
        ...
    }
    *consumed = ptr - buffer;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div></div>

<p>不断从binder_buffer所指向的地址获取cmd, 当只有<code class="highlighter-rouge">BC_TRANSACTION</code>或者<code class="highlighter-rouge">BC_REPLY</code>时, 则调用binder_transaction()来处理事务.</p>

<h4 id="34-binder_transaction">3.4 binder_transaction<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#34-binder_transaction" aria-label="Anchor link for: 34 binder_transaction" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<p>发送的是BC_TRANSACTION时，此时reply=0。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php"><span class="hljs-keyword">static</span> void binder_transaction(struct binder_proc *proc,
               struct binder_thread *thread,
               struct binder_transaction_data *tr, int reply){
     struct binder_transaction *t;
     struct binder_work *tcomplete;
     binder_size_t *offp, *off_end;
     binder_size_t off_min;
     struct binder_proc *target_proc;
     struct binder_thread *target_thread = <span class="hljs-keyword">NULL</span>;
     struct binder_node *target_node = <span class="hljs-keyword">NULL</span>;
     struct list_head *target_list;
     wait_queue_head_t *target_wait;
     struct binder_transaction *in_reply_to = <span class="hljs-keyword">NULL</span>;

    <span class="hljs-keyword">if</span> (reply) {
        ...
    }<span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (tr-&gt;target.handle) {
            struct binder_ref *ref;
            <span class="hljs-comment">// 由handle 找到相应 binder_ref, 由binder_ref 找到相应 binder_node</span>
            ref = binder_get_ref(proc, tr-&gt;target.handle);
            target_node = ref-&gt;node;
        } <span class="hljs-keyword">else</span> {
            target_node = binder_context_mgr_node;
        }
        <span class="hljs-comment">// 由binder_node 找到相应 binder_proc</span>
        target_proc = target_node-&gt;proc;
    }


    <span class="hljs-keyword">if</span> (target_thread) {
        e-&gt;to_thread = target_thread-&gt;pid;
        target_list = &amp;target_thread-&gt;todo;
        target_wait = &amp;target_thread-&gt;wait;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//首次执行target_thread为空</span>
        target_list = &amp;target_proc-&gt;todo;
        target_wait = &amp;target_proc-&gt;wait;
    }

    t = kzalloc(sizeof(*t), GFP_KERNEL);
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);

    <span class="hljs-comment">//非oneway的通信方式，把当前thread保存到transaction的from字段</span>
    <span class="hljs-keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
        t-&gt;from = thread;
    <span class="hljs-keyword">else</span>
        t-&gt;from = <span class="hljs-keyword">NULL</span>;

    t-&gt;sender_euid = task_euid(proc-&gt;tsk);
    t-&gt;to_proc = target_proc; <span class="hljs-comment">//此次通信目标进程为system_server</span>
    t-&gt;to_thread = target_thread;
    t-&gt;code = tr-&gt;code;  <span class="hljs-comment">//此次通信code = START_SERVICE_TRANSACTION</span>
    t-&gt;flags = tr-&gt;flags;  <span class="hljs-comment">// 此次通信flags = 0</span>
    t-&gt;priority = task_nice(current);

    <span class="hljs-comment">//从目标进程target_proc中分配内存空间【3.4.1】</span>
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
        tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));

    t-&gt;buffer-&gt;allow_user_free = <span class="hljs-number">0</span>;
    t-&gt;buffer-&gt;transaction = t;
    t-&gt;buffer-&gt;target_node = target_node;

    <span class="hljs-keyword">if</span> (target_node)
        binder_inc_node(target_node, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">NULL</span>); <span class="hljs-comment">//引用计数加1</span>
    <span class="hljs-comment">//binder对象的偏移量</span>
    offp = (binder_size_t *)(t-&gt;buffer-&gt;data + ALIGN(tr-&gt;data_size, sizeof(void *)));

    <span class="hljs-comment">//分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到目标进程的binder_buffer</span>
    copy_from_user(t-&gt;buffer-&gt;data,
        (<span class="hljs-keyword">const</span> void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size);
    copy_from_user(offp,
        (<span class="hljs-keyword">const</span> void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);

    off_end = (void *)offp + tr-&gt;offsets_size;

    <span class="hljs-keyword">for</span> (; offp &lt; off_end; offp++) {
        struct flat_binder_object *fp;
        fp = (struct flat_binder_object *)(t-&gt;buffer-&gt;data + *offp);
        off_min = *offp + sizeof(struct flat_binder_object);
        <span class="hljs-keyword">switch</span> (fp-&gt;type) {
        ...
        <span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE:
        <span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {
            <span class="hljs-comment">//处理引用计数情况</span>
            struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);
            <span class="hljs-keyword">if</span> (ref-&gt;node-&gt;proc == target_proc) {
                <span class="hljs-keyword">if</span> (fp-&gt;type == BINDER_TYPE_HANDLE)
                    fp-&gt;type = BINDER_TYPE_BINDER;
                <span class="hljs-keyword">else</span>
                    fp-&gt;type = BINDER_TYPE_WEAK_BINDER;
                fp-&gt;binder = ref-&gt;node-&gt;ptr;
                fp-&gt;cookie = ref-&gt;node-&gt;cookie;
                binder_inc_node(ref-&gt;node, fp-&gt;type == BINDER_TYPE_BINDER, <span class="hljs-number">0</span>, <span class="hljs-keyword">NULL</span>);
            } <span class="hljs-keyword">else</span> {    
                struct binder_ref *new_ref;
                new_ref = binder_get_ref_for_node(target_proc, ref-&gt;node);
                fp-&gt;handle = new_ref-&gt;desc;
                binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, <span class="hljs-keyword">NULL</span>);
            }
        } <span class="hljs-keyword">break</span>;
        ...

        <span class="hljs-keyword">default</span>:
            return_error = BR_FAILED_REPLY;
            <span class="hljs-keyword">goto</span> err_bad_object_type;
        }
    }

    <span class="hljs-keyword">if</span> (reply) {
        <span class="hljs-comment">//BC_REPLY的过程</span>
        binder_pop_transaction(target_thread, in_reply_to);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) {
        <span class="hljs-comment">//BC_TRANSACTION 且 非oneway,则设置事务栈信息</span>
        t-&gt;need_reply = <span class="hljs-number">1</span>;
        t-&gt;from_parent = thread-&gt;transaction_stack;
        thread-&gt;transaction_stack = t;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//BC_TRANSACTION 且 oneway,则加入异步todo队列</span>
        <span class="hljs-keyword">if</span> (target_node-&gt;has_async_transaction) {
            target_list = &amp;target_node-&gt;async_todo;
            target_wait = <span class="hljs-keyword">NULL</span>;
        } <span class="hljs-keyword">else</span>
            target_node-&gt;has_async_transaction = <span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">//将BINDER_WORK_TRANSACTION添加到目标队列,即target_proc-&gt;todo</span>
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    list_add_tail(&amp;t-&gt;work.entry, target_list);

    <span class="hljs-comment">//将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程队列，即thread-&gt;todo</span>
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);

    <span class="hljs-comment">//唤醒等待队列，本次通信的目标队列为target_proc-&gt;wait</span>
    <span class="hljs-keyword">if</span> (target_wait)
        wake_up_interruptible(target_wait);
    <span class="hljs-keyword">return</span>;
}
</code></pre></div></div>

<p>主要功能:</p>

<ol>
  <li>查询目标进程的过程： handle -&gt; binder_ref -&gt; binder_node -&gt; binder_proc</li>
  <li>将<code class="highlighter-rouge">BINDER_WORK_TRANSACTION</code>添加到目标队列target_list:
    <ul>
      <li>call事务， 则目标队列target_list=<code class="highlighter-rouge">target_proc-&gt;todo</code>;</li>
      <li>reply事务，则目标队列target_list=<code class="highlighter-rouge">target_thread-&gt;todo</code>;</li>
      <li>async事务，则目标队列target_list=<code class="highlighter-rouge">target_node-&gt;async_todo</code>.</li>
    </ul>
  </li>
  <li>数据拷贝
    <ul>
      <li>将用户空间binder_transaction_data中ptr.buffer和ptr.offsets拷贝到目标进程的binder_buffer-&gt;data；</li>
      <li>这就是只拷贝一次的真理所在；</li>
    </ul>
  </li>
  <li>设置事务栈信息
    <ul>
      <li>BC_TRANSACTION且非oneway, 则将当前事务添加到thread-&gt;transaction_stack；</li>
    </ul>
  </li>
  <li>事务分发过程：
    <ul>
      <li>将<code class="highlighter-rouge">BINDER_WORK_TRANSACTION</code>添加到目标队列(此时为target_proc-&gt;todo队列);</li>
      <li>将<code class="highlighter-rouge">BINDER_WORK_TRANSACTION_COMPLETE</code>添加到当前线程thread-&gt;todo队列;</li>
    </ul>
  </li>
  <li>唤醒目标进程target_proc开始执行事务。</li>
</ol>

<p>该方法中proc/thread是指当前发起方的进程信息，而binder_proc是指目标接收端进程。
此时当前线程thread的todo队列已经有事务, 接下来便会进入binder_thread_read来处理相关的事务.</p>

<h4 id="341-binder_alloc_buf">3.4.1 binder_alloc_buf<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#341-binder_alloc_buf" aria-label="Anchor link for: 341 binder_alloc_buf" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> binder_buffer *binder_alloc_buf(<span class="hljs-keyword">struct</span> binder_proc *proc,
                          size_t data_size, size_t offsets_size, <span class="hljs-keyword">int</span> is_async)
{
    <span class="hljs-keyword">struct</span> rb_node *n = proc-&gt;free_buffers.rb_node;
    <span class="hljs-keyword">struct</span> binder_buffer *buffer;
    size_t buffer_size;
    <span class="hljs-keyword">struct</span> rb_node *best_fit = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">void</span> *has_page_addr;
    <span class="hljs-keyword">void</span> *end_page_addr;
    size_t size;
    ..
    size = ALIGN(data_size, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *)) + ALIGN(offsets_size, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *));
    <span class="hljs-keyword">if</span> (is_async &amp;&amp; proc-&gt;free_async_space &lt; size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binder_buffer)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 剩余可用的异步空间，小于所需的大小</span>
    }
    <span class="hljs-keyword">while</span> (n) {  <span class="hljs-comment">//从binder_buffer的红黑树中查找大小相等的buffer块</span>
        buffer = rb_entry(n, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);
        buffer_size = binder_buffer_size(proc, buffer);
        <span class="hljs-keyword">if</span> (size &lt; buffer_size) {
            best_fit = n;
            n = n-&gt;rb_left;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (size &gt; buffer_size)
            n = n-&gt;rb_right;
        <span class="hljs-keyword">else</span> {
            best_fit = n;
            <span class="hljs-keyword">break</span>;
        }
    }
    ...
    <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>) {
        buffer = rb_entry(best_fit, <span class="hljs-keyword">struct</span> binder_buffer, rb_node);
        buffer_size = binder_buffer_size(proc, buffer);
    }

    has_page_addr =(<span class="hljs-keyword">void</span> *)(((uintptr_t)buffer-&gt;data + buffer_size) &amp; PAGE_MASK);
    <span class="hljs-keyword">if</span> (n == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">if</span> (size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binder_buffer) + <span class="hljs-number">4</span> &gt;= buffer_size)
            buffer_size = size;
        <span class="hljs-keyword">else</span>
            buffer_size = size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binder_buffer);
    }
    <span class="hljs-comment">//末端地址</span>
    end_page_addr =     (<span class="hljs-keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data + buffer_size);
    ...
    <span class="hljs-comment">//分配物理页</span>
    <span class="hljs-keyword">if</span> (binder_update_page_range(proc, <span class="hljs-number">1</span>,
        (<span class="hljs-keyword">void</span> *)PAGE_ALIGN((uintptr_t)buffer-&gt;data), end_page_addr, <span class="hljs-literal">NULL</span>))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
    rb_erase(best_fit, &amp;proc-&gt;free_buffers);
    buffer-&gt;free = <span class="hljs-number">0</span>;
    binder_insert_allocated_buffer(proc, buffer);
    <span class="hljs-keyword">if</span> (buffer_size != size) {
        <span class="hljs-keyword">struct</span> binder_buffer *new_buffer = (<span class="hljs-keyword">void</span> *)buffer-&gt;data + size;
        list_add(&amp;new_buffer-&gt;entry, &amp;buffer-&gt;entry);
        new_buffer-&gt;free = <span class="hljs-number">1</span>;
        binder_insert_free_buffer(proc, new_buffer);
    }

    buffer-&gt;data_size = data_size;
    buffer-&gt;offsets_size = offsets_size;
    buffer-&gt;async_transaction = is_async;
    <span class="hljs-keyword">if</span> (is_async) { <span class="hljs-comment">//调整异步可用内存空间大小</span>
        proc-&gt;free_async_space -= size + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> binder_buffer);
    }
    <span class="hljs-keyword">return</span> buffer;
}
</code></pre></div></div>

<h4 id="35-binder_thread_read">3.5 binder_thread_read<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#35-binder_thread_read" aria-label="Anchor link for: 35 binder_thread_read" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">binder_thread_read（）{
    <span class="hljs-comment">//当已使用字节数为0时，将BR_NOOP响应码放入指针ptr</span>
    <span class="hljs-keyword">if</span> (*consumed == <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">if</span> (put_user(BR_NOOP, (uint32_t __user *)ptr))
                <span class="hljs-keyword">return</span> -EFAULT;
            ptr += sizeof(uint32_t);
        }

retry:
    <span class="hljs-comment">//binder_transaction()已设置transaction_stack不为空，则wait_for_proc_work为false.</span>
    wait_for_proc_work = thread-&gt;transaction_stack == <span class="hljs-keyword">NULL</span> &amp;&amp;
            list_empty(&amp;thread-&gt;todo);

    thread-&gt;looper |= BINDER_LOOPER_STATE_WAITING;
    <span class="hljs-keyword">if</span> (wait_for_proc_work)
      proc-&gt;ready_threads++; <span class="hljs-comment">//进程中空闲binder线程加1</span>

    <span class="hljs-comment">//只有当前线程todo队列为空，并且transaction_stack也为空，才会开始处于当前进程的事务</span>
    <span class="hljs-keyword">if</span> (wait_for_proc_work) {
        <span class="hljs-keyword">if</span> (non_block) {
            ...
        } <span class="hljs-keyword">else</span>
            <span class="hljs-comment">//当进程todo队列没有数据,则进入休眠等待状态</span>
            ret = wait_event_freezable_exclusive(proc-&gt;wait, binder_has_proc_work(proc, thread));
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (non_block) {
            ...
        } <span class="hljs-keyword">else</span>
            <span class="hljs-comment">//当线程todo队列有数据则执行往下执行；当线程todo队列没有数据，则进入休眠等待状态</span>
            ret = wait_event_freezable(thread-&gt;wait, binder_has_thread_work(thread));
    }

    <span class="hljs-keyword">if</span> (wait_for_proc_work)
      proc-&gt;ready_threads--; <span class="hljs-comment">//退出等待状态, 则进程中空闲binder线程减1</span>
    thread-&gt;looper &amp;= ~BINDER_LOOPER_STATE_WAITING;
    ...

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

        uint32_t cmd;
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = <span class="hljs-keyword">NULL</span>;
        <span class="hljs-comment">//先从线程todo队列获取事务数据</span>
        <span class="hljs-keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) {
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        <span class="hljs-comment">// 线程todo队列没有数据, 则从进程todo对获取事务数据</span>
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) {
            w = list_first_entry(&amp;proc-&gt;todo, struct binder_work, entry);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//没有数据,则返回retry</span>
            <span class="hljs-keyword">if</span> (ptr - buffer == <span class="hljs-number">4</span> &amp;&amp;
                !(thread-&gt;looper &amp; BINDER_LOOPER_STATE_NEED_RETURN))
                <span class="hljs-keyword">goto</span> retry;
            <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-keyword">switch</span> (w-&gt;type) {
            <span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION:
                <span class="hljs-comment">//获取transaction数据</span>
                t = container_of(w, struct binder_transaction, work);
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION_COMPLETE:
                cmd = BR_TRANSACTION_COMPLETE;
                <span class="hljs-comment">//将BR_TRANSACTION_COMPLETE写入*ptr，并跳出循环。</span>
                put_user(cmd, (uint32_t __user *)ptr)；
                list_del(&amp;w-&gt;entry);
                kfree(w);
                <span class="hljs-keyword">break</span>;

            <span class="hljs-keyword">case</span> BINDER_WORK_NODE: ...    <span class="hljs-keyword">break</span>;
            <span class="hljs-keyword">case</span> BINDER_WORK_DEAD_BINDER:
            <span class="hljs-keyword">case</span> BINDER_WORK_DEAD_BINDER_AND_CLEAR:
            <span class="hljs-keyword">case</span> BINDER_WORK_CLEAR_DEATH_NOTIFICATION: ...   <span class="hljs-keyword">break</span>;
        }

        <span class="hljs-comment">//只有BINDER_WORK_TRANSACTION命令才能继续往下执行</span>
        <span class="hljs-keyword">if</span> (!t)
            <span class="hljs-keyword">continue</span>;

        <span class="hljs-keyword">if</span> (t-&gt;buffer-&gt;target_node) {
            <span class="hljs-comment">//获取目标node</span>
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            tr.target.ptr = target_node-&gt;ptr;
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            ...
            cmd = BR_TRANSACTION;  <span class="hljs-comment">//设置命令为BR_TRANSACTION</span>
        } <span class="hljs-keyword">else</span> {
            tr.target.ptr = <span class="hljs-keyword">NULL</span>;
            tr.cookie = <span class="hljs-keyword">NULL</span>;
            cmd = BR_REPLY; <span class="hljs-comment">//设置命令为BR_REPLY</span>
        }
        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        <span class="hljs-keyword">if</span> (t-&gt;from) {
            struct task_struct *sender = t-&gt;from-&gt;proc-&gt;tsk;
            <span class="hljs-comment">//当非oneway的情况下,将调用者进程的pid保存到sender_pid</span>
            tr.sender_pid = task_tgid_nr_ns(sender,
                            current-&gt;nsproxy-&gt;pid_ns);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//当oneway的的情况下,则该值为0</span>
            tr.sender_pid = <span class="hljs-number">0</span>;
        }

        tr.data_size = t-&gt;buffer-&gt;data_size;
        tr.offsets_size = t-&gt;buffer-&gt;offsets_size;
        tr.data.ptr.buffer = (void *)t-&gt;buffer-&gt;data + proc-&gt;user_buffer_offset;
        tr.data.ptr.offsets = tr.data.ptr.buffer +
                    ALIGN(t-&gt;buffer-&gt;data_size, sizeof(void *));

        <span class="hljs-comment">//将cmd和数据写回用户空间</span>
        <span class="hljs-keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr))
            <span class="hljs-keyword">return</span> -EFAULT;
        ptr += sizeof(uint32_t);
        <span class="hljs-keyword">if</span> (copy_to_user(ptr, &amp;tr, sizeof(tr)))
            <span class="hljs-keyword">return</span> -EFAULT;
        ptr += sizeof(tr);

        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            t-&gt;to_parent = thread-&gt;transaction_stack;
            t-&gt;to_thread = thread;
            thread-&gt;transaction_stack = t;
        } <span class="hljs-keyword">else</span> {
            t-&gt;buffer-&gt;transaction = <span class="hljs-keyword">NULL</span>;
            kfree(t); <span class="hljs-comment">//通信完成,则运行释放</span>
        }
        <span class="hljs-keyword">break</span>;
    }
done:
    *consumed = ptr - buffer;
    <span class="hljs-comment">//当满足请求线程加已准备线程数等于0，已启动线程数小于最大线程数(15)，</span>
    <span class="hljs-comment">//且looper状态为已注册或已进入时创建新的线程。</span>
    <span class="hljs-keyword">if</span> (proc-&gt;requested_threads + proc-&gt;ready_threads == <span class="hljs-number">0</span> &amp;&amp;
        proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;
        (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |
         BINDER_LOOPER_STATE_ENTERED))) {
        proc-&gt;requested_threads++;
        <span class="hljs-comment">// 生成BR_SPAWN_LOOPER命令，用于创建新的线程</span>
        put_user(BR_SPAWN_LOOPER, (uint32_t __user *)buffer)；
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div></div>

<p>该方法功能说明:</p>

<p>此处wait_for_proc_work是指当前线程todo队列为空，并且transaction_stack也为空,该值为true.</p>

<ol>
  <li>当wait_for_proc_work = false, 则进入线程的等待队列thread-&gt;wait, 直到thread-&gt;todo队列有事务才往下执行;
    <ul>
      <li>获取并处理thread-&gt;todo队列中的事务;将相应的cmd和数据写回用户空间.</li>
    </ul>
  </li>
  <li>当wait_for_proc_work = true, 则进入线程的等待队列proc-&gt;wait, 直到proc-&gt;todo队列有事务才往下执行;
    <ul>
      <li>获取并处理proc-&gt;todo队列中的事务;将相应的cmd和数据写回用户空间.</li>
    </ul>
  </li>
</ol>

<p>到这里,可能有人好奇,对于[小节3.4]介绍了target_list有3种, 这里只会处理前2种:thread-&gt;todo, proc-&gt;todo.那么对于
target_node-&gt;async_todo的处理过程时间呢? [见小节5.4]</p>

<h4 id="36-下一步何去何从">3.6 下一步何去何从<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#36-%E4%B8%8B%E4%B8%80%E6%AD%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E" aria-label="Anchor link for: 36 下一步何去何从" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<ol>
  <li>执行完binder_thread_write方法后, 通过binder_transaction()首先写入<code class="highlighter-rouge">BINDER_WORK_TRANSACTION_COMPLETE</code>写入当前线程.</li>
  <li>这时bwr.read_size &gt; 0, 回到binder_ioctl_write_read方法, 便开始执行binder_thread_read();</li>
  <li>在binder_thread_read()方法, 将获取cmd=BR_TRANSACTION_COMPLETE, 再将cmd和数据写回用户空间;</li>
  <li>一次Binder_ioctl完成,接着回调用户空间方法talkWithDriver(),刚才的数据以写入mIn.</li>
  <li>这时mIn有可读数据, 回到【小节2.10】IPC.waitForResponse()方法,完成BR_TRANSACTION_COMPLETE过程.
如果本次transaction采用非oneway方式, 这次Binder通信便完成, 否则还是要等待Binder服务端的返回。</li>
</ol>

<p>对于startService过程, 采用的便是非oneway方式,那么发起者进程还会继续停留在waitForResponse()方法,继续talkWithDriver()，然后休眠在binder_thread_read()的wait_event_freezable()过程，等待当前线程的todo队列有数据的到来，即等待收到BR_REPLY消息.</p>

<p>由于在前面binder_transaction()除了向自己所在线程写入了<code class="highlighter-rouge">BINDER_WORK_TRANSACTION_COMPLETE</code>, 还向目标进程(此处为system_server)写入了<code class="highlighter-rouge">BINDER_WORK_TRANSACTION</code>命令，那么接下里介绍system_server进程的工作。</p>

<h2 id="四-回到用户空间">四. 回到用户空间<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#%E5%9B%9B-%E5%9B%9E%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4" aria-label="Anchor link for: 四 回到用户空间" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<p><code class="highlighter-rouge">system_server</code>的binder线程是如何运转的，那么就需要从Binder线程的创建开始说起，
Binder线程的创建有两种方式：</p>

<ul>
  <li>ProcessState::self()-&gt;startThreadPool();</li>
  <li>IPCThreadState::self()-&gt;joinThreadPool();</li>
</ul>

<p>从文章<a href="http://gityuan.com/2015/11/14/binder-add-service/">addService 小节4.1</a>，可知，调用链如下：
startThreadPool()过程会创建新Binder线程，再经过层层调用也会进入joinThreadPool()方法。
<code class="highlighter-rouge">system_server</code>的binder线程从IPC.joinThreadPool –&gt;  IPC.getAndExecuteCommand() -&gt;  IPC.talkWithDriver() ,但talkWithDriver收到事务之后, 便进入IPC.executeCommand()方法。</p>

<p>接下来从joinThreadPool说起：</p>

<h3 id="41-ipcjointhreadpool">4.1 IPC.joinThreadPool<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#41-ipcjointhreadpool" aria-label="Anchor link for: 41 ipcjointhreadpool" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">void</span> IPCThreadState::joinThreadPool(<span class="hljs-keyword">bool</span> isMain)
{
    mOut.writeInt32(isMain ? BC_ENTER_LOOPER : BC_REGISTER_LOOPER);
    set_sched_policy(mMyThreadId, SP_FOREGROUND);

    <span class="hljs-keyword">status_t</span> result;
    <span class="hljs-keyword">do</span> {
        processPendingDerefs(); <span class="hljs-comment">//处理对象引用</span>
        result = getAndExecuteCommand();<span class="hljs-comment">//获取并执行命令【见小节4.2】</span>

        <span class="hljs-keyword">if</span> (result &lt; NO_ERROR &amp;&amp; result != TIMED_OUT &amp;&amp; result != -ECONNREFUSED &amp;&amp; result != -EBADF) {
            ALOGE(<span class="hljs-string">"getAndExecuteCommand(fd=%d) returned unexpected error %d, aborting"</span>,
                  mProcess-&gt;mDriverFD, result);
            <span class="hljs-built_in">abort</span>();
        }

        <span class="hljs-comment">//对于binder非主线程不再使用，则退出</span>
        <span class="hljs-keyword">if</span>(result == TIMED_OUT &amp;&amp; !isMain) {
            <span class="hljs-keyword">break</span>;
        }
    } <span class="hljs-keyword">while</span> (result != -ECONNREFUSED &amp;&amp; result != -EBADF);

    mOut.writeInt32(BC_EXIT_LOOPER);
    talkWithDriver(<span class="hljs-literal">false</span>);
}
</code></pre></div></div>

<h3 id="42--ipcgetandexecutecommand">4.2  IPC.getAndExecuteCommand<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#42--ipcgetandexecutecommand" aria-label="Anchor link for: 42  ipcgetandexecutecommand" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">status_t IPCThreadState::getAndExecuteCommand()
{
    status_t result;
    int32_t cmd;

    result = talkWithDriver(); <span class="hljs-comment">//该Binder Driver进行交互</span>
    <span class="hljs-keyword">if</span> (result &gt;= NO_ERROR) {
        size_t IN = mIn.dataAvail();
        <span class="hljs-keyword">if</span> (IN &lt; sizeof(int32_t)) <span class="hljs-keyword">return</span> result;
        cmd = mIn.readInt32(); <span class="hljs-comment">//读取命令</span>

        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);
        mProcess-&gt;mExecutingThreadsCount++;
        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);

        result = executeCommand(cmd); <span class="hljs-comment">//【见小节4.3】</span>

        pthread_mutex_lock(&amp;mProcess-&gt;mThreadCountLock);
        mProcess-&gt;mExecutingThreadsCount--;
        pthread_cond_broadcast(&amp;mProcess-&gt;mThreadCountDecrement);
        pthread_mutex_unlock(&amp;mProcess-&gt;mThreadCountLock);

        set_sched_policy(mMyThreadId, SP_FOREGROUND);
    }
    <span class="hljs-keyword">return</span> result;
}
</code></pre></div></div>

<p>此时system_server的binder线程空闲便是停留在binder_thread_read()方法来处理进程/线程新的事务。
由【小节3.4】可知收到的是<code class="highlighter-rouge">BINDER_WORK_TRANSACTION</code>命令, 再经过inder_thread_read()后生成命令cmd=<code class="highlighter-rouge">BR_TRANSACTION</code>.再将cmd和数据写回用户空间。</p>

<h3 id="43-ipcexecutecommand">4.3 IPC.executeCommand<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#43-ipcexecutecommand" aria-label="Anchor link for: 43 ipcexecutecommand" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> IPCThreadState::executeCommand(<span class="hljs-keyword">int32_t</span> cmd)
{
    BBinder* obj;
    RefBase::weakref_type* refs;
    <span class="hljs-keyword">status_t</span> result = NO_ERROR;

    <span class="hljs-keyword">switch</span> ((<span class="hljs-keyword">uint32_t</span>)cmd) {
        <span class="hljs-keyword">case</span> BR_TRANSACTION:
        {
            binder_transaction_data tr;
            result = mIn.read(&amp;tr, sizeof(tr)); <span class="hljs-comment">//读取mIn数据</span>
            <span class="hljs-keyword">if</span> (result != NO_ERROR) <span class="hljs-keyword">break</span>;

            Parcel buffer;
            <span class="hljs-comment">//当buffer对象回收时，则会调用freeBuffer来回收内存【见小节4.3.1】</span>
            buffer.ipcSetDataReference(
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),
                tr.data_size,
                <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">const</span> <span class="hljs-keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),
                tr.offsets_size/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">binder_size_t</span>), freeBuffer, <span class="hljs-keyword">this</span>);

            <span class="hljs-keyword">const</span> <span class="hljs-keyword">pid_t</span> origPid = mCallingPid;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">uid_t</span> origUid = mCallingUid;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> origStrictModePolicy = mStrictModePolicy;
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">int32_t</span> origTransactionBinderFlags = mLastTransactionBinderFlags;

            <span class="hljs-comment">//设置调用者的pid和uid</span>
            mCallingPid = tr.sender_pid;
            mCallingUid = tr.sender_euid;
            mLastTransactionBinderFlags = tr.flags;

            <span class="hljs-keyword">int</span> curPrio = getpriority(PRIO_PROCESS, mMyThreadId);
            <span class="hljs-keyword">if</span> (gDisableBackgroundScheduling) {
                ... <span class="hljs-comment">//不进入此分支</span>
            } <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">if</span> (curPrio &gt;= ANDROID_PRIORITY_BACKGROUND) {
                    set_sched_policy(mMyThreadId, SP_BACKGROUND);
                }
            }

            Parcel reply;
            <span class="hljs-keyword">status_t</span> error;
            <span class="hljs-keyword">if</span> (tr.target.ptr) {
                <span class="hljs-comment">//尝试通过弱引用获取强引用</span>
                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(
                        tr.target.ptr)-&gt;attemptIncStrong(this)) {

                    <span class="hljs-comment">// tr.cookie里存放的是BBinder子类JavaBBinder [见流程4.4]</span>
                    error = <span class="hljs-keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;transact(tr.code, buffer,
                            &amp;reply, tr.flags);
                    <span class="hljs-keyword">reinterpret_cast</span>&lt;BBinder*&gt;(tr.cookie)-&gt;decStrong(<span class="hljs-keyword">this</span>);
                } <span class="hljs-keyword">else</span> {
                    error = UNKNOWN_TRANSACTION;
                }

            } <span class="hljs-keyword">else</span> {
                error = the_context_object-&gt;transact(tr.code, buffer, &amp;reply, tr.flags);
            }

            <span class="hljs-keyword">if</span> ((tr.flags &amp; TF_ONE_WAY) == <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">if</span> (error &lt; NO_ERROR) reply.setError(error);
                <span class="hljs-comment">//对于非oneway, 需要reply通信过程,则向Binder驱动发送BC_REPLY命令【见小节4.3.1】</span>
                sendReply(reply, <span class="hljs-number">0</span>);
            }
            <span class="hljs-comment">//恢复pid和uid信息</span>
            mCallingPid = origPid;
            mCallingUid = origUid;
            ...
        }
        <span class="hljs-keyword">break</span>;

        <span class="hljs-keyword">case</span> ...

        <span class="hljs-keyword">default</span>:
            result = UNKNOWN_ERROR;
            <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (result != NO_ERROR) {
        mLastError = result;
    }
    return result;
}
</code></pre></div></div>

<ul>
  <li>对于oneway的场景, 执行完本次transact()则全部结束.</li>
  <li>对于非oneway, 需要reply的通信过程,则向Binder驱动发送BC_REPLY命令【见小节5.1】</li>
</ul>

<h4 id="431-ipcsetdatareference">4.3.1 ipcSetDataReference<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#431-ipcsetdatareference" aria-label="Anchor link for: 431 ipcsetdatareference" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; Parcel.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">void</span> Parcel::ipcSetDataReference(<span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* data, <span class="hljs-keyword">size_t</span> dataSize,
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">binder_size_t</span>* objects, <span class="hljs-keyword">size_t</span> objectsCount, release_func relFunc, <span class="hljs-keyword">void</span>* relCookie)
{
    <span class="hljs-keyword">binder_size_t</span> minOffset = <span class="hljs-number">0</span>;
    freeDataNoInit(); <span class="hljs-comment">//【见小节4.3.2】</span>
    mError = NO_ERROR;
    mData = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">uint8_t</span>*&gt;(data);
    mDataSize = mDataCapacity = dataSize;
    mDataPos = <span class="hljs-number">0</span>;
    mObjects = <span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">binder_size_t</span>*&gt;(objects);
    mObjectsSize = mObjectsCapacity = objectsCount;
    mNextObjectHint = <span class="hljs-number">0</span>;
    mOwner = relFunc;
    mOwnerCookie = relCookie;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mObjectsSize; i++) {
        <span class="hljs-keyword">binder_size_t</span> offset = mObjects[i];
        <span class="hljs-keyword">if</span> (offset &lt; minOffset) {
            mObjectsSize = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">break</span>;
        }
        minOffset = offset + <span class="hljs-keyword">sizeof</span>(flat_binder_object);
    }
    scanForFds();
}
</code></pre></div></div>

<p>该方法的功能，Parcel成员变量说明：</p>

<ul>
  <li>mData：parcel数据起始地址</li>
  <li>mDataSize：parcel数据大小</li>
  <li>mObjects：flat_binder_object地址偏移量</li>
  <li>mObjectsSize：parcel中flat_binder_object个数</li>
  <li>mOwner：释放函数freebuffer</li>
  <li>mOwnerCookie：释放函数所需信息</li>
</ul>

<h4 id="432-freedatanoinit">4.3.2 freeDataNoInit<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#432-freedatanoinit" aria-label="Anchor link for: 432 freedatanoinit" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; Parcel.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">void</span> Parcel::freeDataNoInit()
{
    <span class="hljs-keyword">if</span> (mOwner) {
        mOwner(<span class="hljs-keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">//mOwner为空， 进入该分支</span>
        releaseObjects(); <span class="hljs-comment">//【见小节4.3.3】</span>
        <span class="hljs-keyword">if</span> (mData) {
            pthread_mutex_lock(&amp;gParcelGlobalAllocSizeLock);
            <span class="hljs-keyword">if</span> (mDataCapacity &lt;= gParcelGlobalAllocSize) {
              gParcelGlobalAllocSize = gParcelGlobalAllocSize - mDataCapacity;
            } <span class="hljs-keyword">else</span> {
              gParcelGlobalAllocSize = <span class="hljs-number">0</span>;
            }
            <span class="hljs-keyword">if</span> (gParcelGlobalAllocCount &gt; <span class="hljs-number">0</span>) {
              gParcelGlobalAllocCount--;
            }
            pthread_mutex_unlock(&amp;gParcelGlobalAllocSizeLock);
            <span class="hljs-built_in">free</span>(mData);
        }
        <span class="hljs-keyword">if</span> (mObjects) <span class="hljs-built_in">free</span>(mObjects);
    }
}
</code></pre></div></div>

<h4 id="433--releaseobjects">4.3.3  releaseObjects<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#433--releaseobjects" aria-label="Anchor link for: 433  releaseobjects" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">void</span> Parcel::releaseObjects()
{
    <span class="hljs-keyword">const</span> sp&lt;ProcessState&gt; proc(ProcessState::self());
    <span class="hljs-keyword">size_t</span> i = mObjectsSize;
    <span class="hljs-keyword">uint8_t</span>* <span class="hljs-keyword">const</span> data = mData;
    <span class="hljs-keyword">binder_size_t</span>* <span class="hljs-keyword">const</span> objects = mObjects;
    <span class="hljs-keyword">while</span> (i &gt; <span class="hljs-number">0</span>) {
        i--;
        <span class="hljs-keyword">const</span> flat_binder_object* flat
            = <span class="hljs-keyword">reinterpret_cast</span>&lt;flat_binder_object*&gt;(data+objects[i]);
        <span class="hljs-comment">//【见小节4.3.4】</span>
        release_object(proc, *flat, <span class="hljs-keyword">this</span>, &amp;mOpenAshmemSize);
    }
}
</code></pre></div></div>

<h4 id="434-release_object">4.3.4 release_object<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#434-release_object" aria-label="Anchor link for: 434 release_object" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">release_object</span><span class="hljs-params">(<span class="hljs-keyword">const</span> sp&lt;ProcessState&gt;&amp; proc,
    <span class="hljs-keyword">const</span> flat_binder_object&amp; obj, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>* who, size_t* outAshmemSize)</span>
</span>{
    <span class="hljs-keyword">switch</span> (obj.type) {
        <span class="hljs-keyword">case</span> BINDER_TYPE_BINDER:
            <span class="hljs-keyword">if</span> (obj.binder) {
                <span class="hljs-keyword">reinterpret_cast</span>&lt;IBinder*&gt;(obj.cookie)-&gt;decStrong(who);
            }
            return;
        <span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_BINDER:
            <span class="hljs-keyword">if</span> (obj.binder)
                <span class="hljs-keyword">reinterpret_cast</span>&lt;RefBase::weakref_type*&gt;(obj.binder)-&gt;decWeak(who);
            return;
        <span class="hljs-keyword">case</span> BINDER_TYPE_HANDLE: {
            <span class="hljs-keyword">const</span> sp&lt;IBinder&gt; b = proc-&gt;getStrongProxyForHandle(obj.handle);
            <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">NULL</span>) {
                b-&gt;decStrong(who);
            }
            return;
        }
        <span class="hljs-keyword">case</span> BINDER_TYPE_WEAK_HANDLE: {
            <span class="hljs-keyword">const</span> wp&lt;IBinder&gt; b = proc-&gt;getWeakProxyForHandle(obj.handle);
            <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">NULL</span>) b.get_refs()-&gt;decWeak(who);
            return;
        }
        <span class="hljs-keyword">case</span> BINDER_TYPE_FD: {
            ...
            return;
        }
    }
}
</code></pre></div></div>

<p>根据flat_binder_object的类型，来决定减少相应的强弱引用。</p>

<h4 id="435-parcel">4.3.5 ~Parcel<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#435-parcel" aria-label="Anchor link for: 435 parcel" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; Parcel.cpp]</p>

<p>当[小节4.3]executeCommand执行完成后， 便会释放局部变量Parcel buffer，则会析构Parcel。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp">Parcel::~Parcel()
{
    freeDataNoInit();
}

<span class="hljs-keyword">void</span> Parcel::freeDataNoInit()
{
    <span class="hljs-keyword">if</span> (mOwner) { <span class="hljs-comment">//此处mOwner等于freeBuffer 【见小节4.3.6】</span>
        mOwner(<span class="hljs-keyword">this</span>, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
    } <span class="hljs-keyword">else</span> { 
        ...
    }
}
</code></pre></div></div>

<p>接下来，进入IPC的freeBuffer过程。</p>

<h4 id="436-freebuffer">4.3.6 freeBuffer<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#436-freebuffer" aria-label="Anchor link for: 436 freebuffer" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>
<p>[-&gt; IPCThreadState.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">void</span> IPCThreadState::freeBuffer(Parcel* parcel, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* data,
                                <span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*dataSize*/</span>,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">binder_size_t</span>* <span class="hljs-comment">/*objects*/</span>,
                                <span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*objectsSize*/</span>, <span class="hljs-keyword">void</span>* <span class="hljs-comment">/*cookie*/</span>)
{
    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) parcel-&gt;closeFileDescriptors();
    IPCThreadState* state = self();
    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);
    state-&gt;mOut.writePointer((<span class="hljs-keyword">uintptr_t</span>)data);
}
</code></pre></div></div>

<p>向Binder驱动写入BC_FREE_BUFFER命令。</p>

<h3 id="44---bbindertransact">4.4   BBinder.transact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#44---bbindertransact" aria-label="Anchor link for: 44   bbindertransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; Binder.cpp ::BBinder ]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> BBinder::transact(
    <span class="hljs-keyword">uint32_t</span> code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="hljs-keyword">uint32_t</span> flags)
{
    data.setDataPosition(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">status_t</span> err = NO_ERROR;
    <span class="hljs-keyword">switch</span> (code) {
        <span class="hljs-keyword">case</span> PING_TRANSACTION:
            reply-&gt;writeInt32(pingBinder());
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            err = onTransact(code, data, reply, flags); <span class="hljs-comment">//【见流程4.5】</span>
            <span class="hljs-keyword">break</span>;
    }

    <span class="hljs-keyword">if</span> (reply != <span class="hljs-literal">NULL</span>) {
        reply-&gt;setDataPosition(<span class="hljs-number">0</span>);
    }

    return err;
}
</code></pre></div></div>

<h3 id="45-javabbinderontransact">4.5 JavaBBinder.onTransact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#45-javabbinderontransact" aria-label="Anchor link for: 45 javabbinderontransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; android_util_Binder.cpp]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">virtual status_t onTransact(
    uint32_t code, <span class="hljs-keyword">const</span> Parcel&amp; data, Parcel* reply, uint32_t flags = <span class="hljs-number">0</span>)
{
    JNIEnv* env = javavm_to_jnienv(mVM);

    IPCThreadState* thread_state = IPCThreadState::self();

    <span class="hljs-comment">//调用Binder.execTransact [见流程4.6]</span>
    jboolean res = env-&gt;CallBooleanMethod(mObject, gBinderOffsets.mExecTransact,
        code, reinterpret_cast&lt;jlong&gt;(&amp;data), reinterpret_cast&lt;jlong&gt;(reply), flags);

    jthrowable excep = env-&gt;ExceptionOccurred();
    <span class="hljs-keyword">if</span> (excep) {
        res = JNI_FALSE;
        <span class="hljs-comment">//发生异常, 则清理JNI本地引用</span>
        env-&gt;DeleteLocalRef(excep);
    }
    ...
    <span class="hljs-keyword">return</span> res != JNI_FALSE ? NO_ERROR : UNKNOWN_TRANSACTION;
}
</code></pre></div></div>

<p>还记得AndroidRuntime::startReg过程吗, 其中有一个过程便是register_android_os_Binder(),该过程会把gBinderOffsets.mExecTransact便是Binder.java中的execTransact()方法.详见见<a href="http://gityuan.com/2015/11/21/binder-framework/">Binder系列7—framework层分析</a>文章中的第二节初始化的过程.</p>

<p>另外,此处mObject是在服务注册addService过程,会调用writeStrongBinder方法, 将Binder对象传入了JavaBBinder构造函数的参数, 最终赋值给mObject. 在本次通信过程中Object为ActivityManagerNative对象.</p>

<p>此处斗转星移, 从C++代码回到了Java代码. 进入AMN.execTransact, 由于AMN继续于Binder对象, 接下来进入Binder.execTransact</p>

<h3 id="46-binderexectransact">4.6 Binder.execTransact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#46-binderexectransact" aria-label="Anchor link for: 46 binderexectransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[Binder.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">execTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, <span class="hljs-keyword">long</span> dataObj, <span class="hljs-keyword">long</span> replyObj,
        <span class="hljs-keyword">int</span> flags)</span> </span>{
    Parcel data = Parcel.obtain(dataObj);
    Parcel reply = Parcel.obtain(replyObj);

    <span class="hljs-keyword">boolean</span> res;
    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// 调用子类AMN.onTransact方法 [见流程4.7]</span>
        res = onTransact(code, data, reply, flags);
    } <span class="hljs-keyword">catch</span> (RemoteException e) {
        <span class="hljs-keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="hljs-number">0</span>) {
            ...
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">//非oneway的方式,则会将异常写回reply</span>
            reply.setDataPosition(<span class="hljs-number">0</span>);
            reply.writeException(e);
        }
        res = <span class="hljs-keyword">true</span>;
    } <span class="hljs-keyword">catch</span> (RuntimeException e) {
        <span class="hljs-keyword">if</span> ((flags &amp; FLAG_ONEWAY) != <span class="hljs-number">0</span>) {
            ...
        } <span class="hljs-keyword">else</span> {
            reply.setDataPosition(<span class="hljs-number">0</span>);
            reply.writeException(e);
        }
        res = <span class="hljs-keyword">true</span>;
    } <span class="hljs-keyword">catch</span> (OutOfMemoryError e) {
        RuntimeException re = <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"Out of memory"</span>, e);
        reply.setDataPosition(<span class="hljs-number">0</span>);
        reply.writeException(re);
        res = <span class="hljs-keyword">true</span>;
    }
    reply.recycle();
    data.recycle();
    <span class="hljs-keyword">return</span> res;
}
</code></pre></div></div>

<p>当发生RemoteException, RuntimeException, OutOfMemoryError, 对于非oneway的情况下都会把异常传递给调用者.</p>

<h3 id="47-amnontransact">4.7 AMN.onTransact<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#47-amnontransact" aria-label="Anchor link for: 47 amnontransact" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>
<p>[-&gt; ActivityManagerNative.java]</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onTransact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, Parcel data, Parcel reply, <span class="hljs-keyword">int</span> flags)</span>
        <span class="hljs-keyword">throws</span> RemoteException </span>{
    <span class="hljs-keyword">switch</span> (code) {
    ...
     <span class="hljs-keyword">case</span> START_SERVICE_TRANSACTION: {
        data.enforceInterface(IActivityManager.descriptor);
        IBinder b = data.readStrongBinder();
        <span class="hljs-comment">//生成ApplicationThreadNative的代理对象，即ApplicationThreadProxy对象</span>
        IApplicationThread app = ApplicationThreadNative.asInterface(b);
        Intent service = Intent.CREATOR.createFromParcel(data);
        String resolvedType = data.readString();
        String callingPackage = data.readString();
        <span class="hljs-keyword">int</span> userId = data.readInt();
        <span class="hljs-comment">//调用ActivityManagerService的startService()方法【见流程4.8】</span>
        ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);
        reply.writeNoException();
        ComponentName.writeToParcel(cn, reply);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}
</code></pre></div></div>

<h3 id="48-amsstartservice">4.8 AMS.startService<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#48-amsstartservice" aria-label="Anchor link for: 48 amsstartservice" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ComponentName <span class="hljs-title">startService</span><span class="hljs-params">(IApplicationThread caller, Intent service,
        String resolvedType, String callingPackage, <span class="hljs-keyword">int</span> userId)</span>
        <span class="hljs-keyword">throws</span> TransactionTooLargeException </span>{

    <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>) {
        ...
        ComponentName res = mServices.startServiceLocked(caller, service,
                resolvedType, callingPid, callingUid, callingPackage, userId);
        Binder.restoreCallingIdentity(origId);
        <span class="hljs-keyword">return</span> res;
    }
}
</code></pre></div></div>

<p>历经千山万水, 总算是进入了AMS.startService. 当system_server收到BR_TRANSACTION的过程后，通信并没有完全结束，还需将服务启动完成的回应消息
告诉给发起端进程。</p>

<h2 id="五-reply流程">五. Reply流程<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%BA%94-reply%E6%B5%81%E7%A8%8B" aria-label="Anchor link for: 五 reply流程" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<p>还记得前面【小节2.10】IPC.waitForResponse()过程，对于非oneway的方式，还仍在一直等待system_server这边的响应呢，只有收到BR_REPLY，或者BR_DEAD_REPLY，或者BR_FAILED_REPLY，再或许其他BR_命令执行出错的情况下，该waitForResponse()才会退出。</p>

<p>BR_REPLY命令是如何来的呢？【小节4.3】IPC.executeCommand()过程处理完BR_TRANSACTION命令的同时，还会通过sendReply()向Binder Driver发送BC_REPLY消息，接下来从该方法说起。</p>

<h4 id="51-ipcsendreply">5.1 IPC.sendReply<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#51-ipcsendreply" aria-label="Anchor link for: 51 ipcsendreply" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">status_t IPCThreadState::sendReply(<span class="hljs-keyword">const</span> Parcel&amp; reply, uint32_t flags)
{
    status_t err;
    status_t statusBuffer;
    <span class="hljs-comment">//[见小节2.10]</span>
    err = writeTransactionData(BC_REPLY, flags, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, reply, &amp;statusBuffer);
    <span class="hljs-keyword">if</span> (err &lt; NO_ERROR) <span class="hljs-keyword">return</span> err;
    <span class="hljs-comment">//[见小节5.3]</span>
    <span class="hljs-keyword">return</span> waitForResponse(<span class="hljs-keyword">NULL</span>, <span class="hljs-keyword">NULL</span>);
}
</code></pre></div></div>

<p>先将数据写入mOut；再进waitForResponse，等待应答，此时同理也是等待BR_TRANSACTION_COMPLETE。
同理经过IPC.talkWithDriver -&gt; binder_ioctl -&gt; binder_ioctl_write_read -&gt; binder_thread_write，
再就是进入binder_transaction方法。</p>

<h4 id="52--bc_reply">5.2  BC_REPLY<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#52--bc_reply" aria-label="Anchor link for: 52  bc_reply" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php"><span class="hljs-comment">// reply =true</span>
<span class="hljs-keyword">static</span> void binder_transaction(struct binder_proc *proc,
             struct binder_thread *thread,
             struct binder_transaction_data *tr, int reply)
{
  ...
  <span class="hljs-keyword">if</span> (reply) {
    in_reply_to = thread-&gt;transaction_stack; <span class="hljs-comment">//接收端的事务栈</span>
    ...
    thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;
    target_thread = in_reply_to-&gt;from; <span class="hljs-comment">//发起端的线程</span>

        <span class="hljs-comment">//发起端线程不能为空</span>
    <span class="hljs-keyword">if</span> (target_thread == <span class="hljs-keyword">NULL</span>) {
      return_error = BR_DEAD_REPLY;
      <span class="hljs-keyword">goto</span> err_dead_binder;
    }

        <span class="hljs-comment">//发起端线程的事务栈 要等于 接收端的事务栈</span>
    <span class="hljs-keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) {
      return_error = BR_FAILED_REPLY;
      in_reply_to = <span class="hljs-keyword">NULL</span>;
      target_thread = <span class="hljs-keyword">NULL</span>;
      <span class="hljs-keyword">goto</span> err_dead_binder;
    }
    target_proc = target_thread-&gt;proc; <span class="hljs-comment">//发起端的进程</span>
  } <span class="hljs-keyword">else</span> {
    ...
  }

  <span class="hljs-keyword">if</span> (target_thread) {
      <span class="hljs-comment">//发起端的线程</span>
      target_list = &amp;target_thread-&gt;todo;
      target_wait = &amp;target_thread-&gt;wait;
    } <span class="hljs-keyword">else</span> {
      ...
    }

    t = kzalloc(sizeof(*t), GFP_KERNEL);
    tcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);
    ...

    <span class="hljs-keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))
      t-&gt;from = thread;
    <span class="hljs-keyword">else</span>
      t-&gt;from = <span class="hljs-keyword">NULL</span>; <span class="hljs-comment">//进入该分支</span>
    t-&gt;sender_euid = task_euid(proc-&gt;tsk);
    t-&gt;to_proc = target_proc;
    t-&gt;to_thread = target_thread;
    t-&gt;code = tr-&gt;code;
    t-&gt;flags = tr-&gt;flags;
    t-&gt;priority = task_nice(current);

    <span class="hljs-comment">// 发起端进程分配buffer</span>
    t-&gt;buffer = binder_alloc_buf(target_proc, tr-&gt;data_size,
      tr-&gt;offsets_size, !reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));
    ...
    t-&gt;buffer-&gt;allow_user_free = <span class="hljs-number">0</span>;
    t-&gt;buffer-&gt;transaction = t;
    t-&gt;buffer-&gt;target_node = target_node;
    <span class="hljs-keyword">if</span> (target_node)
      binder_inc_node(target_node, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">NULL</span>);

    <span class="hljs-comment">//分别拷贝用户空间的binder_transaction_data中ptr.buffer和ptr.offsets到内核</span>
    copy_from_user(t-&gt;buffer-&gt;data,
       (<span class="hljs-keyword">const</span> void __user *)(uintptr_t)tr-&gt;data.ptr.buffer, tr-&gt;data_size);
    copy_from_user(offp,
       (<span class="hljs-keyword">const</span> void __user *)(uintptr_t)tr-&gt;data.ptr.offsets, tr-&gt;offsets_size);
    ...

    <span class="hljs-keyword">if</span> (reply) {
      binder_pop_transaction(target_thread, in_reply_to);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) {
      ...
    } <span class="hljs-keyword">else</span> {
      ...
    }

    <span class="hljs-comment">//将BINDER_WORK_TRANSACTION添加到目标队列，本次通信的目标队列为target_thread-&gt;todo</span>
    t-&gt;work.type = BINDER_WORK_TRANSACTION;
    list_add_tail(&amp;t-&gt;work.entry, target_list);

    <span class="hljs-comment">//将BINDER_WORK_TRANSACTION_COMPLETE添加到当前线程的todo队列</span>
    tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;
    list_add_tail(&amp;tcomplete-&gt;entry, &amp;thread-&gt;todo);

    <span class="hljs-comment">//唤醒等待队列，本次通信的目标队列为target_thread-&gt;wait</span>
    <span class="hljs-keyword">if</span> (target_wait)
        wake_up_interruptible(target_wait);
    <span class="hljs-keyword">return</span>;
</code></pre></div></div>

<p>binder_transaction -&gt; binder_thread_read -&gt; IPC.waitForResponse，收到BR_REPLY来回收buffer.</p>

<h4 id="53-br_reply">5.3 BR_REPLY<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#53-br_reply" aria-label="Anchor link for: 53 br_reply" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="hljs-keyword">status_t</span> *acquireResult)
{
    <span class="hljs-keyword">int32_t</span> cmd;
    <span class="hljs-keyword">int32_t</span> err;

    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 【见小节2.11】</span>
        <span class="hljs-keyword">if</span> (mIn.dataAvail() == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
        ...
        cmd = mIn.readInt32();
        <span class="hljs-keyword">switch</span> (cmd) {
          ...
          <span class="hljs-keyword">case</span> BR_REPLY:
           {
               binder_transaction_data tr;
               err = mIn.read(&amp;tr, sizeof(tr));
               <span class="hljs-keyword">if</span> (err != NO_ERROR) <span class="hljs-keyword">goto</span> finish;

               <span class="hljs-keyword">if</span> (reply) {
                   ...
               } <span class="hljs-keyword">else</span> {
                   <span class="hljs-comment">// 释放buffer[见小节5.4]</span>
                   freeBuffer(NULL,
                       reinterpret_cast&lt;const <span class="hljs-keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),
                       tr.data_size,
                       reinterpret_cast&lt;const <span class="hljs-keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),
                       tr.offsets_size/sizeof(<span class="hljs-keyword">binder_size_t</span>), this);
                   <span class="hljs-keyword">continue</span>;
               }
           }
           <span class="hljs-keyword">goto</span> finish;
        <span class="hljs-keyword">default</span>:
            err = executeCommand(cmd);
            ...
            <span class="hljs-keyword">break</span>;
        }
    }
    ...
}
</code></pre></div></div>

<h4 id="54-ipcfreebuffer">5.4 IPC.freeBuffer<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#54-ipcfreebuffer" aria-label="Anchor link for: 54 ipcfreebuffer" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs cpp"><span class="hljs-keyword">void</span> IPCThreadState::freeBuffer(Parcel* parcel, <span class="hljs-keyword">const</span> <span class="hljs-keyword">uint8_t</span>* data,
                                <span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*dataSize*/</span>,
                                <span class="hljs-keyword">const</span> <span class="hljs-keyword">binder_size_t</span>* <span class="hljs-comment">/*objects*/</span>,
                                <span class="hljs-keyword">size_t</span> <span class="hljs-comment">/*objectsSize*/</span>, <span class="hljs-keyword">void</span>* <span class="hljs-comment">/*cookie*/</span>)
{
    <span class="hljs-keyword">if</span> (parcel != <span class="hljs-literal">NULL</span>) parcel-&gt;closeFileDescriptors();
    IPCThreadState* state = self();
    state-&gt;mOut.writeInt32(BC_FREE_BUFFER);
    state-&gt;mOut.writePointer((<span class="hljs-keyword">uintptr_t</span>)data);
}
</code></pre></div></div>

<p>将BC_FREE_BUFFER写入mOut,再talkWithDriver()</p>

<h5 id="55-bc_free_buffer">5.5 BC_FREE_BUFFER<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#55-bc_free_buffer" aria-label="Anchor link for: 55 bc_free_buffer" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs objectivec"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> binder_thread_write(<span class="hljs-keyword">struct</span> binder_proc *proc,
            <span class="hljs-keyword">struct</span> binder_thread *thread,
            binder_uintptr_t binder_buffer, size_t size,
            binder_size_t *consumed)
{
    uint32_t cmd;
    <span class="hljs-keyword">void</span> __user *buffer = (<span class="hljs-keyword">void</span> __user *)(uintptr_t)binder_buffer;
    <span class="hljs-keyword">void</span> __user *ptr = buffer + *consumed;
    <span class="hljs-keyword">void</span> __user *end = buffer + size;
    <span class="hljs-keyword">while</span> (ptr &lt; end &amp;&amp; thread-&gt;return_error == BR_OK) {
        <span class="hljs-comment">//拷贝用户空间的cmd命令，此时为BC_FREE_BUFFER</span>
        <span class="hljs-keyword">if</span> (get_user(cmd, (uint32_t __user *)ptr)) -EFAULT;
        ptr += <span class="hljs-keyword">sizeof</span>(uint32_t);
        <span class="hljs-keyword">switch</span> (cmd) {
        <span class="hljs-keyword">case</span> BC_TRA<span class="hljs-built_in">NSACTION</span>:
        <span class="hljs-keyword">case</span> BC_REPLY: ...
        <span class="hljs-keyword">case</span> BC_FREE_BUFFER: {
            <span class="hljs-keyword">void</span> __user *data_ptr;
            <span class="hljs-keyword">struct</span> binder_buffer *buffer;

            <span class="hljs-keyword">if</span> (get_user(data_ptr, (<span class="hljs-keyword">void</span> * __user *)ptr)) <span class="hljs-keyword">return</span> -EFAULT;
            ptr += <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">void</span> *);

            buffer = binder_buffer_lookup(proc, data_ptr);
            ...

            <span class="hljs-keyword">if</span> (buffer-&gt;transaction) {
                buffer-&gt;transaction-&gt;buffer = <span class="hljs-literal">NULL</span>;
                buffer-&gt;transaction = <span class="hljs-literal">NULL</span>;
            }
            <span class="hljs-comment">// binder_buffer存在异步事务,且binder_node不为空</span>
            <span class="hljs-keyword">if</span> (buffer-&gt;async_transaction &amp;&amp; buffer-&gt;target_node) {
                <span class="hljs-keyword">if</span> (list_empty(&amp;buffer-&gt;target_node-&gt;async_todo))
                    buffer-&gt;target_node-&gt;has_async_transaction = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">else</span>
                    <span class="hljs-comment">//当异步队列async_todo也不为空,则事务追加到该线程todo队列.</span>
                    list_move_tail(buffer-&gt;target_node-&gt;async_todo.next, &amp;thread-&gt;todo);
            }

            binder_transaction_buffer_release(proc, buffer, <span class="hljs-literal">NULL</span>);
            binder_free_buf(proc, buffer);
            <span class="hljs-keyword">break</span>;
        }
    }
    *consumed = ptr - buffer;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div></div>

<p>接收端线程处理BC_FREE_BUFFER命令:</p>

<ul>
  <li>当binder_buffer存在异步事务,当异步队列async_todo也不为空,则事务追加到该线程todo队列.</li>
  <li>释放当前的buffer.</li>
</ul>

<h5 id="56--binder_thread_read">5.6  binder_thread_read<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#56--binder_thread_read" aria-label="Anchor link for: 56  binder_thread_read" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code class="hljs php">binder_thread_read（）{
    ...
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {

        uint32_t cmd;
        struct binder_transaction_data tr;
        struct binder_work *w;
        struct binder_transaction *t = <span class="hljs-keyword">NULL</span>;

        <span class="hljs-comment">//从线程todo队列获取事务数据</span>
        <span class="hljs-keyword">if</span> (!list_empty(&amp;thread-&gt;todo)) {
            w = list_first_entry(&amp;thread-&gt;todo, struct binder_work, entry);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!list_empty(&amp;proc-&gt;todo) &amp;&amp; wait_for_proc_work) {
            ...
        } <span class="hljs-keyword">else</span> {
            ...
        }

        <span class="hljs-keyword">switch</span> (w-&gt;type) {
            <span class="hljs-keyword">case</span> BINDER_WORK_TRANSACTION:
                <span class="hljs-comment">//获取transaction数据</span>
                t = container_of(w, struct binder_transaction, work);
                <span class="hljs-keyword">break</span>;

            ...
        }

        ...
        <span class="hljs-keyword">if</span> (t-&gt;buffer-&gt;target_node) {
            <span class="hljs-comment">//获取目标node</span>
            struct binder_node *target_node = t-&gt;buffer-&gt;target_node;
            tr.target.ptr = target_node-&gt;ptr;
            tr.cookie =  target_node-&gt;cookie;
            t-&gt;saved_priority = task_nice(current);
            ...
            cmd = BR_TRANSACTION;  <span class="hljs-comment">//设置命令为BR_TRANSACTION</span>
        } <span class="hljs-keyword">else</span> {
            tr.target.ptr = <span class="hljs-keyword">NULL</span>;
            tr.cookie = <span class="hljs-keyword">NULL</span>;
            cmd = BR_REPLY; <span class="hljs-comment">//设置命令为BR_REPLY</span>
        }

        tr.code = t-&gt;code;
        tr.flags = t-&gt;flags;
        tr.sender_euid = t-&gt;sender_euid;

        ...
        <span class="hljs-comment">//将cmd和数据写回用户空间</span>
        <span class="hljs-keyword">if</span> (put_user(cmd, (uint32_t __user *)ptr)) <span class="hljs-keyword">return</span> -EFAULT;
        ptr += sizeof(uint32_t);
        <span class="hljs-keyword">if</span> (copy_to_user(ptr, &amp;tr, sizeof(tr)))  <span class="hljs-keyword">return</span> -EFAULT;
        ptr += sizeof(tr);

        list_del(&amp;t-&gt;work.entry);
        t-&gt;buffer-&gt;allow_user_free = <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (cmd == BR_TRANSACTION &amp;&amp; !(t-&gt;flags &amp; TF_ONE_WAY)) {
            t-&gt;to_parent = thread-&gt;transaction_stack;
            t-&gt;to_thread = thread;
            thread-&gt;transaction_stack = t;
        } <span class="hljs-keyword">else</span> {
            t-&gt;buffer-&gt;transaction = <span class="hljs-keyword">NULL</span>;
            kfree(t); <span class="hljs-comment">//通信完成,则运行释放</span>
        }
        <span class="hljs-keyword">break</span>;
    }

    ...
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre></div></div>

<h2 id="六-总结">六. 总结<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#%E5%85%AD-%E6%80%BB%E7%BB%93" aria-label="Anchor link for: 六 总结" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h2>

<p>本文详细地介绍如何从AMP.startService是如何通过Binder一步步调用进入到system_server进程的AMS.startService. 整个过程涉及Java framework, native, kernel driver各个层面知识. 仅仅一个Binder IPC调用, 就花费了如此大篇幅来讲解, 可见系统之庞大. 整个过程的调用流程:</p>

<h3 id="61-通信流程">6.1 通信流程<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#61-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B" aria-label="Anchor link for: 61 通信流程" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>从通信流程角度来看整个过程:
<img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/binder_ipc_process.jpg" alt="binder_ipc_process"></p>

<p>图解:</p>

<ol>
  <li>发起端线程向Binder Driver发起binder ioctl请求后, 便采用环不断talkWithDriver,此时该线程处于阻塞状态, 直到收到如下BR_XXX命令才会结束该过程.
    <ul>
      <li>BR_TRANSACTION_COMPLETE: oneway模式下,收到该命令则退出</li>
      <li>BR_REPLY: 非oneway模式下,收到该命令才退出;</li>
      <li>BR_DEAD_REPLY: 目标进程/线程/binder实体为空, 以及释放正在等待reply的binder thread或者binder buffer;</li>
      <li>BR_FAILED_REPLY: 情况较多,比如非法handle, 错误事务栈, security, 内存不足, buffer不足, 数据拷贝失败, 节点创建失败, 各种不匹配等问题</li>
      <li>BR_ACQUIRE_RESULT: 目前未使用的协议;</li>
    </ul>
  </li>
  <li>左图中waitForResponse收到BR_TRANSACTION_COMPLETE,则直接退出循环, 则没有机会执行executeCommand()方法, 故将其颜色画为灰色. 除以上5种BR_XXX命令, 当收到其他BR命令,则都会执行executeCommand过程.</li>
  <li>目标Binder线程创建后, 便进入joinThreadPool()方法, 采用循环不断地循环执行getAndExecuteCommand()方法, 当bwr的读写buffer都没有数据时,则阻塞在binder_thread_read的wait_event过程.  另外,正常情况下binder线程一旦创建则不会退出.</li>
</ol>

<h3 id="62-通信协议">6.2 通信协议<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#62-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE" aria-label="Anchor link for: 62 通信协议" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>从通信协议的角度来看这个过程:</p>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/binder_transaction.jpg" alt="binder_transaction"></p>

<ul>
  <li>Binder客户端或者服务端向Binder Driver发送的命令都是以BC_开头,例如本文的<code class="highlighter-rouge">BC_TRANSACTION</code>和<code class="highlighter-rouge">BC_REPLY</code>, 所有Binder Driver向Binder客户端或者服务端发送的命令则都是以BR_开头, 例如本文中的<code class="highlighter-rouge">BR_TRANSACTION</code>和<code class="highlighter-rouge">BR_REPLY</code>.</li>
  <li>只有当<code class="highlighter-rouge">BC_TRANSACTION</code>或者<code class="highlighter-rouge">BC_REPLY</code>时, 才调用binder_transaction()来处理事务. 并且都会回应调用者一个<code class="highlighter-rouge">BINDER_WORK_TRANSACTION_COMPLETE</code>事务, 经过binder_thread_read()会转变成<code class="highlighter-rouge">BR_TRANSACTION_COMPLETE</code>.</li>
  <li>startService过程便是一个非oneway的过程, 那么oneway的通信过程如下所述.</li>
</ul>

<h3 id="63-说一说oneway">6.3 说一说oneway<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#63-%E8%AF%B4%E4%B8%80%E8%AF%B4oneway" aria-label="Anchor link for: 63 说一说oneway" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p>上图是非oneway通信过程的协议图, 下图则是对于oneway场景下的通信协议图:</p>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/binder_transaction_oneway.jpg" alt="binder_transaction_oneway"></p>

<p>当收到BR_TRANSACTION_COMPLETE则程序返回,有人可能觉得好奇,为何oneway怎么还要等待回应消息? 我举个例子,你就明白了.</p>

<p>你(app进程)要给远方的家人(system_server进程)邮寄一封信(transaction), 你需要通过邮寄员(Binder Driver)来完成.整个过程如下:</p>

<ol>
  <li>你把信交给邮寄员(<code class="highlighter-rouge">BC_TRANSACTION</code>);</li>
  <li>邮寄员收到信后, 填一张单子给你作为一份回执(<code class="highlighter-rouge">BR_TRANSACTION_COMPLETE</code>). 这样你才放心知道邮递员已确定接收信, 否则就这样走了,信到底有没有交到邮递员手里都不知道,这样的通信实在太让人不省心, 长时间收不到远方家人的回信, 无法得知是在路的中途信件丢失呢,还是压根就没有交到邮递员的手里. 所以说oneway也得知道信是投递状态是否成功.</li>
  <li>邮递员利用交通工具(Binder Driver),将信交给了你的家人(<code class="highlighter-rouge">BR_TRANSACTION</code>);</li>
</ol>

<p>当你收到回执(BR_TRANSACTION_COMPLETE)时心里也不期待家人回信, 那么这便是一次oneway的通信过程.</p>

<p>如果你希望家人回信, 那便是非oneway的过程,在上述步骤2后并不是直接返回,而是继续等待着收到家人的回信, 经历前3个步骤之后继续执行:</p>

<ol>
  <li>家人收到信后, 立马写了个回信交给邮递员<code class="highlighter-rouge">BC_REPLY</code>;</li>
  <li>同样,邮递员要写一个回执(<code class="highlighter-rouge">BR_TRANSACTION_COMPLETE</code>)给你家人;</li>
  <li>邮递员再次利用交通工具(Binder Driver), 将回信成功交到你的手上(<code class="highlighter-rouge">BR_REPLY</code>)</li>
</ol>

<p>这便是一次完成的非oneway通信过程.</p>

<p>oneway与非oneway: 都是需要等待Binder Driver的回应消息BR_TRANSACTION_COMPLETE. 主要区别在于oneway的通信收到BR_TRANSACTION_COMPLETE则返回,而不会再等待BR_REPLY消息的到来. 另外，oneway的binder IPC则接收端无法获取对方的pid.</p>

<h3 id="64-小规律">6.4 小规律<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#64-%E5%B0%8F%E8%A7%84%E5%BE%8B" aria-label="Anchor link for: 64 小规律" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<ul>
  <li>BC_TRANSACTION +  BC_REPLY =  BR_TRANSACTION_COMPLETE +  BR_DEAD_REPLY +  BR_FAILED_REPLY</li>
  <li>Binder线程只有当本线程的thread-&gt;todo队列为空，并且thread-&gt;transaction_stack也为空，才会去处理当前进程的事务，
否则会继续处理或等待当前线程的todo队列事务。换句话说，就是只有当前线程的事务;</li>
  <li>binder_thread_write: 添加成员到todo队列;</li>
  <li>binder_thread_read: 消耗todo队列;</li>
  <li>对于处于空闲可用的,或者Ready的binder线程是指停在binder_thread_read()的wait_event地方的Binder线程;</li>
  <li>每一次BR_TRANSACTION或者BR_REPLY结束之后都会调用freeBuffer().</li>
  <li>ProcessState.mHandleToObject记录着handle与对应的BpBinder信息。</li>
</ul>

<p>整个过程copy once便是指binder_transaction()过程把binder_transaction_data-&gt;data拷贝到目标进程的buffer。</p>

<h3 id="65-数据流">6.5 数据流<a class="anchorjs-link " href="http://gityuan.com/2016/09/04/binder-start-service/#65-%E6%95%B0%E6%8D%AE%E6%B5%81" aria-label="Anchor link for: 65 数据流" data-anchorjs-icon="#" style="opacity: 1; padding-left: 0.375em;"></a></h3>

<p><img src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/binder_transaction_data.jpg" alt="binder_transaction_data"></p>

<ul>
  <li>[2.1]AMP.startService：组装flat_binder_object对象等组成的Parcel data；</li>
  <li>[2.9]IPC.writeTransactionData：组装BC_TRANSACTION和binder_transaction_data结构体，写入mOut;</li>
  <li>[2.11]IPC.talkWithDriver: 组装BINDER_WRITE_READ和binder_write_read结构体，通过ioctl传输到驱动层。</li>
</ul>

<p>进入驱动后</p>

<ul>
  <li>[3.3]binder_thread_write: 处理binder_write_read.write_buffer数据</li>
  <li>[3.4]binder_transaction: 处理write_buffer.binder_transaction_data数据；
    <ul>
      <li>创建binder_transaction结构体，记录事务通信的线程来源以及事务链条等相关信息；</li>
      <li>分配binder_buffer结构体，拷贝当前线程binder_transaction_data的data数据到binder_buffer-&gt;data；</li>
    </ul>
  </li>
  <li>[3.5]binder_thread_read:  处理binder_transaction结构体数据
    <ul>
      <li>组装cmd=BR_TRANSACTION和binder_transaction_data结构体，写入binder_write_read.read_buffer数据</li>
    </ul>
  </li>
</ul>

<p>回到用户空间</p>

<ul>
  <li>[4.3]IPC.executeCommand：处理BR_TRANSACTION命令, 将binder_transaction_data数据解析成BBinder.transact()所需的参数</li>
  <li>[4.7] AMN.onTransact: 层层回调，进入该方法，反序列化数据后，调用startService()方法。</li>
</ul>

								<hr>
								<a target="_blank" href="http://weibo.com/gityuan">
	<font color="#f57e42" data-darkreader-inline-color="" style="--darkreader-inline-color:#ad8067;"><strong>weibo.com/gityuan</strong></font>
</a>
<font color="#004B97" data-darkreader-inline-color="" style="--darkreader-inline-color:#93acbe;"><strong>微博关注  |  </strong></font>

<a target="_blank" href="http://gityuan.com/talk/">
	<font color="#f57e42" data-darkreader-inline-color="" style="--darkreader-inline-color:#ad8067;"><strong>留言区</strong></font>
</a>
<font color="#004B97" data-darkreader-inline-color="" style="--darkreader-inline-color:#93acbe;"><strong>技术交流  |  </strong></font>
<a target="_blank" href="http://gityuan.com/images/about-me/gityuan_pay.jpg">
	<font color="#f57e42" data-darkreader-inline-color="" style="--darkreader-inline-color:#ad8067;"><strong>¥打赏支持</strong></font>
</a>

                <hr>
								

                <ul class="pager">
                    
                    <li class="previous">
                        <a target="_blank" href="http://gityuan.com/2016/09/03/binder-debug-3/" data-toggle="tooltip" data-placement="top" title="Binder子系统之调试分析(三)">
                        上一篇<br>
                        <span>Binder子系统之调试分析(三)</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a target="_blank" href="http://gityuan.com/2016/09/17/android-lowmemorykiller/" data-toggle="tooltip" data-placement="top" title="Android LowMemoryKiller原理分析">
                        下一篇<br>
                        <span>Android LowMemoryKiller原理分析</span>
                        </a>
                    </li>
                    
                </ul>


                

            </div>  

    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog fixed">
                    <hr class="hidden-sm hidden-xs">
                    <h5 id="catalog">
                        <a class="catalog-toggle" href="http://gityuan.com/2016/09/04/binder-start-service/#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"><li class="h2_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%B8%80-%E5%BC%95%E8%A8%80" rel="nofollow">一. 引言</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#11-binder%E6%9E%B6%E6%9E%84%E7%9A%84%E6%80%9D%E8%80%83" rel="nofollow">1.1 Binder架构的思考</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#12-%E5%88%86%E6%9E%90%E8%B5%B7%E7%82%B9" rel="nofollow">1.2 分析起点</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#13-binder-ipc%E5%8E%9F%E7%90%86" rel="nofollow">1.3 Binder IPC原理</a></li><li class="h2_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%BA%8C-%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B" rel="nofollow">二. 通信过程</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#21-ampstartservice" rel="nofollow">2.1 AMP.startService</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#22-parcelobtain" rel="nofollow">2.2 Parcel.obtain</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#221-new-parcel" rel="nofollow">2.2.1 new Parcel</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#222--android_os_parcel_create" rel="nofollow">2.2.2  android_os_Parcel_create</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#223-parcelrecycle" rel="nofollow">2.2.3 Parcel.recycle</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#23-writestring" rel="nofollow">2.3 writeString</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#231-nativewritestring" rel="nofollow">2.3.1 nativeWriteString</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#232-writestring16" rel="nofollow">2.3.2 writeString16</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#24-mremote%E7%A9%B6%E7%AB%9F%E4%B8%BA%E4%BD%95%E7%89%A9" rel="nofollow">2.4 mRemote究竟为何物</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#241-amngetdefault" rel="nofollow">2.4.1 AMN.getDefault</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#242-gdefaultget" rel="nofollow">2.4.2 gDefault.get</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#243-gdefaultcreate" rel="nofollow">2.4.3 gDefault.create</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#244-amnasinterface" rel="nofollow">2.4.4 AMN.asInterface</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#245--querylocalinterface" rel="nofollow">2.4.5  queryLocalInterface</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#246-%E5%88%9B%E5%BB%BAamp" rel="nofollow">2.4.6 创建AMP</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#25-mremotetransact" rel="nofollow">2.5 mRemote.transact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#26-android_os_binderproxy_transact" rel="nofollow">2.6 android_os_BinderProxy_transact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#27-bpbindertransact" rel="nofollow">2.7 BpBinder.transact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#28-ipctransact" rel="nofollow">2.8 IPC.transact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#29-ipcwritetransactiondata" rel="nofollow">2.9 IPC.writeTransactionData</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#210-ipcwaitforresponse" rel="nofollow">2.10 IPC.waitForResponse</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#211--ipctalkwithdriver" rel="nofollow">2.11  IPC.talkWithDriver</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#212--ipcexecutecommand" rel="nofollow">2.12  IPC.executeCommand</a></li><li class="h2_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%B8%89binder-driver" rel="nofollow">三、Binder driver</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#31-binder_ioctl" rel="nofollow">3.1 binder_ioctl</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#32--binder_ioctl_write_read" rel="nofollow">3.2  binder_ioctl_write_read</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#33-binder_thread_write" rel="nofollow">3.3 binder_thread_write</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#34-binder_transaction" rel="nofollow">3.4 binder_transaction</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#341-binder_alloc_buf" rel="nofollow">3.4.1 binder_alloc_buf</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#35-binder_thread_read" rel="nofollow">3.5 binder_thread_read</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#36-%E4%B8%8B%E4%B8%80%E6%AD%A5%E4%BD%95%E5%8E%BB%E4%BD%95%E4%BB%8E" rel="nofollow">3.6 下一步何去何从</a></li><li class="h2_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#%E5%9B%9B-%E5%9B%9E%E5%88%B0%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4" rel="nofollow">四. 回到用户空间</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#41-ipcjointhreadpool" rel="nofollow">4.1 IPC.joinThreadPool</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#42--ipcgetandexecutecommand" rel="nofollow">4.2  IPC.getAndExecuteCommand</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#43-ipcexecutecommand" rel="nofollow">4.3 IPC.executeCommand</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#431-ipcsetdatareference" rel="nofollow">4.3.1 ipcSetDataReference</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#432-freedatanoinit" rel="nofollow">4.3.2 freeDataNoInit</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#433--releaseobjects" rel="nofollow">4.3.3  releaseObjects</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#434-release_object" rel="nofollow">4.3.4 release_object</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#435-parcel" rel="nofollow">4.3.5 ~Parcel</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#436-freebuffer" rel="nofollow">4.3.6 freeBuffer</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#44---bbindertransact" rel="nofollow">4.4   BBinder.transact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#45-javabbinderontransact" rel="nofollow">4.5 JavaBBinder.onTransact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#46-binderexectransact" rel="nofollow">4.6 Binder.execTransact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#47-amnontransact" rel="nofollow">4.7 AMN.onTransact</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#48-amsstartservice" rel="nofollow">4.8 AMS.startService</a></li><li class="h2_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#%E4%BA%94-reply%E6%B5%81%E7%A8%8B" rel="nofollow">五. Reply流程</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#51-ipcsendreply" rel="nofollow">5.1 IPC.sendReply</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#52--bc_reply" rel="nofollow">5.2  BC_REPLY</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#53-br_reply" rel="nofollow">5.3 BR_REPLY</a></li><li class="h4_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#54-ipcfreebuffer" rel="nofollow">5.4 IPC.freeBuffer</a></li><li class="h5_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#55-bc_free_buffer" rel="nofollow">5.5 BC_FREE_BUFFER</a></li><li class="h5_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#56--binder_thread_read" rel="nofollow">5.6  binder_thread_read</a></li><li class="h2_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#%E5%85%AD-%E6%80%BB%E7%BB%93" rel="nofollow">六. 总结</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#61-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B" rel="nofollow">6.1 通信流程</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#62-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE" rel="nofollow">6.2 通信协议</a></li><li class="h3_nav active"><a href="http://gityuan.com/2016/09/04/binder-start-service/#63-%E8%AF%B4%E4%B8%80%E8%AF%B4oneway" rel="nofollow">6.3 说一说oneway</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#64-%E5%B0%8F%E8%A7%84%E5%BE%8B" rel="nofollow">6.4 小规律</a></li><li class="h3_nav"><a href="http://gityuan.com/2016/09/04/binder-start-service/#65-%E6%95%B0%E6%8D%AE%E6%B5%81" rel="nofollow">6.5 数据流</a></li></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5 id="-1"><a target="_blank" href="http://gityuan.com/tags/">标签</a></h5>
                    <div class="tags">
                      
                            <a target="_blank" href="http://gityuan.com/tags/#android" title="android" rel="152">
                                    android
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E7%BB%84%E4%BB%B6%E7%B3%BB%E5%88%97" title="组件系列" rel="19">
                                    组件系列
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#else" title="else" rel="3">
                                    else
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#debug" title="debug" rel="19">
                                    debug
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E6%9D%83%E9%99%90" title="权限" rel="2">
                                    权限
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#web" title="web" rel="2">
                                    web
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#tool" title="tool" rel="12">
                                    tool
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#java" title="java" rel="12">
                                    java
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#performance" title="performance" rel="4">
                                    performance
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#app" title="app" rel="2">
                                    app
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#algorithm" title="algorithm" rel="1">
                                    algorithm
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E8%BF%9B%E7%A8%8B%E7%B3%BB%E5%88%97" title="进程系列" rel="13">
                                    进程系列
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E8%99%9A%E6%8B%9F%E6%9C%BA" title="虚拟机" rel="1">
                                    虚拟机
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#memory" title="memory" rel="5">
                                    memory
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#jvm" title="jvm" rel="5">
                                    jvm
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#linux" title="linux" rel="11">
                                    linux
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#binder" title="binder" rel="19">
                                    binder
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#ipc" title="ipc" rel="3">
                                    ipc
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#handler" title="handler" rel="3">
                                    handler
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#process" title="process" rel="6">
                                    process
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#power" title="power" rel="1">
                                    power
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8" title="系统启动" rel="6">
                                    系统启动
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#AMS" title="AMS" rel="2">
                                    AMS
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#PMS" title="PMS" rel="1">
                                    PMS
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E8%87%AA%E5%AD%A6%E7%BC%96%E7%A8%8B" title="自学编程" rel="1">
                                    自学编程
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#stability" title="stability" rel="8">
                                    stability
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E7%BB%84%E4%BB%B6" title="组件" rel="3">
                                    组件
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#art" title="art" rel="2">
                                    art
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#graphic" title="graphic" rel="1">
                                    graphic
                            </a>
                      
                            <a target="_blank" href="http://gityuan.com/tags/#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B" title="实战案例" rel="7">
                                    实战案例
                            </a>
                      
                    </div>
                </section> 
                 

                <!-- Friends Blog -->
                <!-- 
                 -->
            </div>
        </div>
    </div>
</article>






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style><style class="darkreader darkreader--sync" media="screen"></style>



    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
										
                    
                    
                    
                    
                    <li>
                        <a target="_blank" href="https://www.linkedin.com/in/gityuan">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://gityuan.com/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright © Gityuan  2019 | Powered by Jekyll with Hux Theme
                </p>
                <!-- 流量统计 -->
								<div style="display:none">
                                    <!--
									<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000098804'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000098804%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>-->
                                    
                                    <!-- Baidu Tongji -->
                                    <script>
                                    var _hmt = _hmt || [];
                                    (function() {
                                      var hm = document.createElement("script");
                                      hm.src = "https://hm.baidu.com/hm.js?3b1c71bfd9641a47009f87240c135d75";
                                      var s = document.getElementsByTagName("script")[0]; 
                                      s.parentNode.insertBefore(hm, s);
                                    })();
                                    </script>
								</div>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/jquery.min.js.download"></script>

<!-- Bootstrap Core JavaScript -->
<script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/bootstrap.min.js.download"></script>

<!-- Custom Theme JavaScript -->
<script src="./彻底理解Android Binder通信架构 - Gityuan博客 _ 袁辉辉的Android博客_files/hux-blog.min.js.download"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>






</body></html>